{"./":{"url":"./","title":"介绍","keywords":"","body":"介绍 注意: 本文档针对的是REST framework的版本3。 编写本文档时，所用的版本号： Django(1.11.10) djangorestframework(3.7.7) Python(3.6.4) Django REST framework 是一个功能强大的灵活的构建Web APIs的工具包。 为什么要使用REST framework ? 基于Web 浏览器的API 可视化，对于你的开发将会有很大的帮助 身份认证策略包含OAuth1a和OAuth2 同时支持ORM和非ORM的数据源的序列化 完整的REST API 功能支持, 包括认证、权限、限流、分页等 可定制化 - 如果不需要功能强大的特性，那么可以基于基础的功能类(function-based)进行开发 文档完善，社区活跃 Mozilla, Red Hat 等公司正在使用REST framework 什么人适合本文档？ 阅读本文档之前，至少要对Django有一定的了解。 项目源码 项目源码存放于Github上，https://github.com/bigtree6688/djangorestframework-book。 在线阅读 可以通过GitBook或者Github来在线阅读。 目录 安装 介绍 安装 举例 快速上手 创建项目 序列化 视图 路由 Settings 测试API 完整教程 序列化 Requests & Responses 类视图 认证和权限 关系和超链接 视图集合和路由 coreapi API指南 Requests Responses 视图Views 通用视图Generic views 视图组Viewsets 路由器Routers 解析器Parsers 渲染器Renderers 序列化 Serializer fields Serializer relations 校验器Validators 身份验证 权限 限流Throttling 过滤 分页 API 版本化 内容协商Content negotiation 元数据 Schemas Format suffixes Returning URLs 异常处理 状态码 测试 Settings 最佳实践 API文档生成 "},"home/install.html":{"url":"home/install.html","title":"安装","keywords":"","body":"依赖环境 REST framework 有以下依赖: Python (2.7, 3.2, 3.3, 3.4, 3.5, 3.6) Django (1.10, 1.11, 2.0) 下面的包是可选的： coreapi (1.32.0+) - 生成schema支持 Markdown (2.1.0+) - 可视化的API支持 django-filter (1.0.1+) - 过滤支持 django-crispy-forms - 为过滤提供更好的HTML显示 django-guardian (1.1.1+) - 对象级别的权限支持 安装 使用pip可以安装REST framework和其他任何的可选安装包： pip install django==1.11.10 pip install djangorestframework==3.7.7 pip install markdown # 为可视化API 提供支持 pip install django-filter # 过滤支持 或者是从github克隆项目: git clone git@github.com:encode/django-rest-framework.git 添加'rest_framework'到Django的INSTALLED_APPS设置中： # Application definition INSTALLED_APPS = [ …… 'rest_framework', ] 如果你打算使用可视化的API，那么你可能需要REST framework的登录和登出功能。在你的root urls.py中增加如下内容: urlpatterns = [ …… url(r'^api-auth/', include('rest_framework.urls', namespace='rest_framework')) ] 注意：url的路径可以随便定义,但是必须include('rest_framework.urls') "},"home/example.html":{"url":"home/example.html","title":"举例","keywords":"","body":"举例 让我们看一个用REST framework来构建一个简单的基于model的API。 我们将创建一个可读写的API来访问我们项目的用户信息。 所有关于REST framework的全局配置都放置在一个名为REST_FRAMEWORK的字典中。首先在settings.py中增加如下内容： REST_FRAMEWORK = { # 使用Django 标准的 `django.contrib.auth` 权限, # 或者 对于 未认证的用户提供只读权限. 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.DjangoModelPermissionsOrAnonReadOnly' ] } 提示： 不要忘记在INSTALLED_APPS中添加rest_framework。 现在，我们准备创建API。下面是我们项目的root urls.py模块： from django.conf.urls import url from django.contrib import admin from django.conf.urls import include from django.contrib.auth.models import User from rest_framework import routers from rest_framework import serializers from rest_framework import viewsets # Serializers 定义了API 数据的表现形式 class UserSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = User fields = ('url', 'username', 'email', 'is_staff') # Viewsets 定义了视图行为 class UserViewset(viewsets.ModelViewSet): queryset = User.objects.all() serializer_class = UserSerializer # Routers 提供了一个非常便捷的方式 自动生成 URL 配置 router = routers.DefaultRouter() router.register(r'user', UserViewset) # 将自动生成的URL 配置 放置在真正的路由配置中 # 此外, 我们还配置登录 登出的 路由 urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^api/', include(router.urls)), url(r'^api-auth/', include('rest_framework.urls', namespace='rest_framework')) ] 下面让我们创建一个Django用户: python manage.py makemigrations python manage.py migrate python manage.py createsuperuser 现在你可以在浏览器输入http://127.0.0.1:8001/api/(地址和端口根据自己启动的情况而定)来查看usersAPI。 点击users的API链接，进入如下界面： 右上角有登录按钮，如果登录, 那么就可以创建或者删除用户, 登录之后，界面如下： 注意， 这个界面只能进行users的创建。POST方法。 点击某个用户的URL，这里是http://127.0.0.1:8001/api/user/1/，就会进入某个对象的界面，如下： 注意，这个界面可以对某个具体的对象(这里是用户), 进行更新或者删除的操作。 PUT 和 DELETE方法。 "},"quickstart/project.html":{"url":"quickstart/project.html","title":"创建项目","keywords":"","body":"介绍 在本章我们会创建一个简单的API来允许管理员账号可以查看和编辑用户和用户组。 项目设置 创建一个新的项目，命名为tutorial, 然后开启一个新的app，命名为quickstart。 # 创建项目目录 mkdir tutorial cd tutorial # 创建虚拟的环境 mkvirtualenv --no-site-packages -p /usr/local/bin/python3 env # 在虚拟环境中安装Django和 Django REST framework pip install django==1.11.10 pip install djangorestframework==3.7.7 # 创建一个新的项目并启动一个APP django-admin.py startproject tutorial . # 注意最后的 . 字符 cd tutorial/ django-admin.py startapp quickstart cd .. 此时项目的目录结构如下： tree ./ ./ ├── manage.py └── tutorial ├── __init__.py ├── quickstart │ ├── __init__.py │ ├── admin.py │ ├── apps.py │ ├── migrations │ │ └── __init__.py │ ├── models.py │ ├── tests.py │ └── views.py ├── settings.py ├── urls.py └── wsgi.py 3 directories, 12 files 在项目的目录中创建应用，这种方式看起来和常规的方式不同。这里的目的主要为为了利用项目的命名空间，来避免和外部的其他模块造成冲突。 现在，进行首次的数据库同步： python manage.py migrate 接下来我们创建一个初始的用户，用户名为admin, 密码为password123。 python manage.py createsuperuser --email admin@example.com --username admin 现在一切就绪，进入app目录，开始编码吧... "},"quickstart/serializers.html":{"url":"quickstart/serializers.html","title":"序列化","keywords":"","body":"序列化 首先我们要定义序列化器。让我们创建一个新的模块tutorial/quickstart/serializers.py #!/usr/bin/env python from django.contrib.auth.models import User, Group from rest_framework import serializers class UserSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = User fields = ('url', 'username', 'email', 'groups') class GroupSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = Group fields = ('url', 'name') 注意：在本例中我们使用HyperlinkedModelSerializer来实现一个超链接关系。当然你还可以使用主键关系或者其他各种各样的关系，不过在RESTful API设计中超链接是最好的方式。 "},"quickstart/views.html":{"url":"quickstart/views.html","title":"视图","keywords":"","body":"视图 现在，我们该写一些视图了，打开tutorial/quickstart/views.py #!/usr/bin/env python from django.contrib.auth.models import User, Group from rest_framework import viewsets from tutorial.quickstart.serializers import UserSerializer, GroupSerializer class UserViewSet(viewsets.ModelViewSet): \"\"\" API endpoint 允许 查看 或者 编辑 用户 \"\"\" queryset = User.objects.all().order_by('-date_joined') serializer_class = UserSerializer class GroupViewSet(viewsets.ModelViewSet): \"\"\" API endpoint 允许 查看 或者 编辑 用户组 \"\"\" queryset = Group.objects.all() serializer_class = GroupSerializer 和传统的做法不一样，我们不是将多个视图写在一起，而是将所有公共行为集合viewsets类中。 如果有需求，可以很轻松的将各个功能拆解到单独的视图中，但是使用viewsets可以保证我们的视图非常的干净整洁。 "},"quickstart/urls.html":{"url":"quickstart/urls.html","title":"路由","keywords":"","body":"路由 现在让我们连接API到路由中，在tutorial/urls.py from django.conf.urls import url from django.conf.urls import include from rest_framework import routers from tutorial.quickstart import views router = routers.DefaultRouter() router.register(r'users', views.UserViewSet) router.register(r'groups', views.GroupViewSet) # 将自动生成的URL 配置 放置在真正的路由配置中 # 此外, 我们还配置登录 登出的 路由 urlpatterns = [ url(r'^', include(router.urls)), url(r'^api-auth', include('rest_framework.urls', namespace='rest_framework')) ] 因为我们使用的是viewsets(视图集合)而不是多个视图views。所以我们可以通过将viewsets注册到router类中来自动的生成API相关的URL。 如果，我们需要对API URL进行更多的控制，那么可以降低到使用常规的class-based基于类的视图的，然后对每个URL 进行详细的控制。 最后，我们为可视化的API添加了登录/登出视图。当然，这是可选的，但是这对于可视化API和一些需要认证的API这是非常有必要的。 "},"quickstart/settings.html":{"url":"quickstart/settings.html","title":"Settings","keywords":"","body":"Settings 增加'rest_framework'到INSTALLED_APPS。文件位于tutorial/settings.py # Application definition INSTALLED_APPS = [ …… 'rest_framework', ] OK, 一切就绪。 "},"quickstart/testing.html":{"url":"quickstart/testing.html","title":"测试API","keywords":"","body":"测试API 现在，让我们来测试我们构建的API, 首先启动服务器 python manage.py runserver 使用curl来访问我们的API curl -H 'Accept: application/json; indent=4' -u admin:password123 http://127.0.0.1:8000/users/ [ { \"url\": \"http://127.0.0.1:8000/users/1/\", \"username\": \"admin\", \"email\": \"admin@example.com\", \"groups\": [] } ] 或者直接通过浏览器来访问 注意，右上角的登录按钮。 Great，如此简单快捷。 想要了解更深入的内容，请继续以下的内容。 "},"tutorial/serialization.html":{"url":"tutorial/serialization.html","title":"序列化","keywords":"","body":"序列化 介绍 本章将介绍，如何创建一个简单的支持代码高亮的WebAPI。在此过程中，我们将介绍构成REST framework框架的各个组件，并让您对所有组件的组合方式有一个全面的了解。 此章教程比较深入，所以请花一些时间仔细的阅读。 如果您只想快速浏览一下，则应该转到快速入门文档。 注意：本教程的代码可以在GitHub的tomchristie/rest-framework-tutorial库中找到。线上测试版，请点击这里。 创建一个新的ENV环境 在我们做任何事情之前，我们都应使用virtualenv创建一个新的虚拟环境。这将保证我们的配置与我们正在进行的其他任何项目的配置保持良好的隔离。 virtualenv env source env/bin/activate 现在我们进入了virtualenv环境，然后安装我们所需的依赖包： pip install django pip install djangorestframework pip install pygments # 这个库用作语法高亮 注意：要随时退出virtualenv环境，只需键入deactivate。要了解更多信息，请参阅virtualenv文档。 开始 首先创建一个新的项目： cd ~ django-admin.py startproject tutorial cd tutorial 项目创建成功后,我们可以创建一个app, 我们将用它来创建一个简单的WebAPI。 python manage.py startapp snippets 我们需要在INSTALLED_APPS添加新snippetsapp和rest_frameworkapp。 编辑这个tutorial/settings.py文件： INSTALLED_APPS = ( ... 'rest_framework', 'snippets.apps.SnippetsConfig', ) 创建model 首先将先创建一个简单的Snippet Model, 创建snippets/models.py文件。 注意:良好的编程实践是包括注释的。在官方代码版本库里可以找到注释,此处省略了注释,只需要关注代码即可。 from django.db import models from pygments.lexers import get_all_lexers from pygments.styles import get_all_styles LEXERS = [item for item in get_all_lexers() if item[1]] LANGUAGE_CHOICES = sorted([(item[1][0], item[0]) for item in LEXERS]) STYLE_CHOICES = sorted((item, item) for item in get_all_styles()) class Snippet(models.Model): created = models.DateTimeField(auto_now_add=True) title = models.CharField(max_length=100, blank=True, default='') code = models.TextField() linenos = models.BooleanField(default=False) language = models.CharField(choices=LANGUAGE_CHOICES, default='python', max_length=100) style = models.CharField(choices=STYLE_CHOICES, default='friendly', max_length=100) class Meta: ordering = ('created',) 我们根据snippet model初始化,并且同步到数据库。 python manage.py makemigrations snippets python manage.py migrate 创建一个Serializer 类 第一步，我们需要为WebAPI提供一个用于序列化和反序列化的方法，用来把snippet对象转换成json数据格式。我们可以通过声明与Django表单(forms)非常相似的序列化器(serializers)来实现这一点。 在snippets目录中创建一个文件serializers.py并添加以下内容： from rest_framework import serializers from snippets.models import Snippet, LANGUAGE_CHOICES, STYLE_CHOICES class SnippetSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(required=False, allow_blank=True, max_length=100) code = serializers.CharField(style={'base_template': 'textarea.html'}) linenos = serializers.BooleanField(required=False) language = serializers.ChoiceField(choices=LANGUAGE_CHOICES, default='python') style = serializers.ChoiceField(choices=STYLE_CHOICES, default='friendly') def create(self, validated_data): \"\"\" 如果数据合法有效，创建并返回一个新的`Snippet`实例。 \"\"\" return Snippet.objects.create(**validated_data) def update(self, instance, validated_data): \"\"\" 如果数据合法有效，更新并返回一个已存在的`Snippet`段实例。 \"\"\" instance.title = validated_data.get('title', instance.title) instance.code = validated_data.get('code', instance.code) instance.linenos = validated_data.get('linenos', instance.linenos) instance.language = validated_data.get('language', instance.language) instance.style = validated_data.get('style', instance.style) instance.save() return instance 这个序列化器(serializers)类的第一部分定义了序列化/反序列化的字段。 该类中的create()和update()方法则定义了，当我们调用serializer.save()时如何创建或修改实例。 序列化器(serializers)类与Django Form类非常相似，并在各个字段中包含类似的数据校验标志，例如required，max_length和default。 上面的字段标志还可以控制在某些情况下应该如何展示序列化程序。例如当渲染为HTML时，{'base_template': 'textarea.html'}标志等同于Django Form类中的widget=widgets.Textarea。这对于控制如何显示可浏览的API特别有用，我们将在本教程后面看到的。 我们实际上也可以通过使用这个ModelSerializer类节省一些时间，我们在后面会看到，但现在我们应该先理解序列化器是如何定义的。 使用Serializers 在进一步讨论之前，我们将先熟悉使用序列化器(Serializer)类。让我们进入Django shell： python manage.py shell 我们导入一些模块, 然后创建一些实例： from snippets.models import Snippet from snippets.serializers import SnippetSerializer from rest_framework.renderers import JSONRenderer from rest_framework.parsers import JSONParser snippet = Snippet(code='foo = \"bar\"\\n') snippet.save() snippet = Snippet(code='print \"hello, world\"\\n') snippet.save() 现在我们已经有可操作的实例了。让我们来看看序列化其中一个实例： serializer = SnippetSerializer(snippet) serializer.data # {'id': 2, 'title': u'', 'code': u'print \"hello, world\"\\n', 'linenos': False, 'language': u'python', 'style': u'friendly'} 我们已经将模型实例转换为Python原生数据类型。我们将数据转换为json,完成序列化： content = JSONRenderer().render(serializer.data) content # '{\"id\": 2, \"title\": \"\", \"code\": \"print \\\\\"hello, world\\\\\"\\\\n\", \"linenos\": false, \"language\": \"python\", \"style\": \"friendly\"}' 反序列化也是相似的。首先，我们将一个stream解析为Python原生数据类型： from django.utils.six import BytesIO stream = BytesIO(content) data = JSONParser().parse(stream) 然后，我们将这些原生数据类型转换为对象： serializer = SnippetSerializer(data=data) serializer.is_valid() # True serializer.validated_data # OrderedDict([('title', ''), ('code', 'print \"hello, world\"\\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')]) serializer.save() # 这个API和Django Form的工作方式是多么相似。当我们开始使用序列化器编写视图(view)的时候，相似性应该变得更加明显。 我们还可以序列化queryset(查询结果集)，而不是模型实例。为了实现这一操作，我们只需要在序列化器参数中添加many=True标记。 serializer = SnippetSerializer(Snippet.objects.all(), many=True) serializer.data # [OrderedDict([('id', 1), ('title', u''), ('code', u'foo = \"bar\"\\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')]), OrderedDict([('id', 2), ('title', u''), ('code', u'print \"hello, world\"\\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')]), OrderedDict([('id', 3), ('title', u''), ('code', u'print \"hello, world\"'), ('linenos', False), ('language', 'python'), ('style', 'friendly')])] 使用ModelSerializers 我们SnippetSerializer类和SnippetModel中的大量信息都是重复的。如果我们能让代码更简洁一点，那就更好了！ 就像Django提供Form类和ModelForm类一样，REST框架包含Serializer类和ModelSerializer类。 让我们用ModelSerializer类重构我们的序列化程序。打开snippets/serializers.py文件，并用下面的代码替换。 class SnippetSerializer(serializers.ModelSerializer): class Meta: model = Snippet fields = ('id', 'title', 'code', 'linenos', 'language', 'style') 可以通过打印来检查序列化程序实例中的所有字段。使用python manage.py shell打开Django shell，然后尝试以下操作： from snippets.serializers import SnippetSerializer serializer = SnippetSerializer() print(repr(serializer)) # SnippetSerializer(): # id = IntegerField(label='ID', read_only=True) # title = CharField(allow_blank=True, max_length=100, required=False) # code = CharField(style={'base_template': 'textarea.html'}) # linenos = BooleanField(required=False) # language = ChoiceField(choices=[('Clipper', 'FoxPro'), ('Cucumber', 'Gherkin'), ('RobotFramework', 'RobotFramework'), ('abap', 'ABAP'), ('ada', 'Ada')... # style = ChoiceField(choices=[('autumn', 'autumn'), ('borland', 'borland'), ('bw', 'bw'), ('colorful', 'colorful')... 记住ModelSerializer类没有做任何特别的事情，它们只是创建serializer的一个快捷方式: 自动检查并确定字段。 简单的实现了create()和update()方法。 使用Serializer来编写正常的Django视图 我们来看看如何使用新的Serializer类来编写一些API视图。目前，我们不会使用任何REST框架的其他功能，我们只会将视图编写为常规的Django视图。 编辑snippets/views.py文件，并添加以下内容。 from django.http import HttpResponse, JsonResponse from django.views.decorators.csrf import csrf_exempt from rest_framework.renderers import JSONRenderer from rest_framework.parsers import JSONParser from snippets.models import Snippet from snippets.serializers import SnippetSerializer 我们的API最基本的功能是，支持列出所有snippets实例，或新建一个snippets实例。 @csrf_exempt def snippet_list(request): \"\"\" 展示所有的snippets, 或者创建一个新的snippet. \"\"\" if request.method == 'GET': snippets = Snippet.objects.all() serializer = SnippetSerializer(snippets, many=True) return JsonResponse(serializer.data, safe=False) elif request.method == 'POST': data = JSONParser().parse(request) serializer = SnippetSerializer(data=data) if serializer.is_valid(): serializer.save() return JsonResponse(serializer.data, status=201) return JsonResponse(serializer.errors, status=400) 请注意，因为我们希望没有CSRF令牌的客户端访问到这个视图，所以我们需要将视图标记为csrf_exempt。正常情况下你不应该这么做，并且REST framework提供了更高级更安全的做法，但它现在就可以满足我们需求。 我们还需要另外一个视图，可以用来查看，更新或删除操作。 @csrf_exempt def snippet_detail(request, pk): \"\"\" 查看, 更新 或者 删除 一个 snippet. \"\"\" try: snippet = Snippet.objects.get(pk=pk) except Snippet.DoesNotExist: return HttpResponse(status=404) if request.method == 'GET': serializer = SnippetSerializer(snippet) return JsonResponse(serializer.data) elif request.method == 'PUT': data = JSONParser().parse(request) serializer = SnippetSerializer(snippet, data=data) if serializer.is_valid(): serializer.save() return JsonResponse(serializer.data) return JsonResponse(serializer.errors, status=400) elif request.method == 'DELETE': snippet.delete() return HttpResponse(status=204) 最后，我们把这些联系起来。创建snippets/urls.py文件： from django.conf.urls import url from snippets import views urlpatterns = [ url(r'^snippets/$', views.snippet_list), url(r'^snippets/(?P[0-9]+)/$', views.snippet_detail), ] 我们还需要在tutorial/urls.py文件引用我们应用程序的URL。 from django.conf.urls import url, include urlpatterns = [ url(r'^', include('snippets.urls')), ] 值得注意的是，我们目前还没有处理好几个细节。如果我们发送的是畸形的json，或者如果一个不支持的HTTP请求方法，那么我们最终会收到500\"服务器错误\"响应。 测试我们第一个Web API 现在我们启动服务。 首先退出shell： quit() 并启动Django的服务器。 python manage.py runserver Validating models... 0 errors found Django version 1.11, using settings 'tutorial.settings' Development server is running at http://127.0.0.1:8000/ Quit the server with CONTROL-C. 在另一个终端窗口中，我们可以测试服务器。 我们可以使用curl或httpie来测试我们的API 。Httpie是用Python编写的用户友好的http客户端。让我们先安装。 您可以使用pip安装httpie： pip install httpie 最后，我们可以得到所有snippets的列表： http http://127.0.0.1:8000/snippets/ HTTP/1.1 200 OK ... [ { \"id\": 1, \"title\": \"\", \"code\": \"foo = \\\"bar\\\"\\n\", \"linenos\": false, \"language\": \"python\", \"style\": \"friendly\" }, { \"id\": 2, \"title\": \"\", \"code\": \"print \\\"hello, world\\\"\\n\", \"linenos\": false, \"language\": \"python\", \"style\": \"friendly\" } ] 或者我们可以通过引用snippet的id来get一个对应的实例： http http://127.0.0.1:8000/snippets/2/ HTTP/1.1 200 OK ... { \"id\": 2, \"title\": \"\", \"code\": \"print \\\"hello, world\\\"\\n\", \"linenos\": false, \"language\": \"python\", \"style\": \"friendly\" } 同样，您可以通过在Web浏览器中访问URL来显示相同​​的json。 我们现在在哪 目前为止，我们已经有了一个序列化API，它与Django的Forms API以及一些常规的Django视图非常相似。 我们的API视图目前不做其他的事情，除了服务json响应之外，还有一些我们仍然希望清理的错误处理边缘案例，但这是一个正常运行的Web API。 我们将看到此教程第2部分Requests & Responses。 "},"tutorial/req-resp.html":{"url":"tutorial/req-resp.html","title":"Requests & Responses","keywords":"","body":"Requests & Responses 从这一章，我们将真正开始涵盖REST框架的核心。我们先来介绍一些基本的构建块。 请求对象 REST框架引入了一个Request扩展常规的对象HttpRequest，并提供更灵活的请求解析。Request对象的核心功能是request.data属性，与request.POSTWeb API 类似，但更加有用。 request.POST # 只处理form表单数据,只适用POST方法. request.data # 处理任意方法. 'POST', 'PUT' 和 'PATCH' 方法. 响应对象 REST框架还引入了一个Response对象，该对象是一种TemplateResponse类型，它使用未呈现的内容并使用内容协商来确定返回给客户端的正确内容类型。 return Response(data) # 根据用户请求返回的内容. 状态码 在视图中使用数字HTTP状态代码并不总是明显的阅读，而且如果错误代码出现错误，会很不容易注意到。REST框架为每个状态代码提供更明确的标识符，例如HTTP_400_BAD_REQUEST在status模块中。这是一个好想法，而不是使用数字标识符。 Wrapping API views 装饰 API 视图 REST框架提供了两个可用于编写API视图的装饰器。 @api_view用于处理基于函数的视图的装饰器。 APIView 基于类的视图工作。 这些装饰器提供了一些功能，例如确保Request在视图中接收实例，并向Response对象添加上下文，以便可以执行内容协商。 这些装饰器还提供了一些功能，例如405 Method Not Allowed在适当的时候返回响应，以及处理ParseError在request.data访问输入错误的格式时发生的任何异常。 Pulling it all together 整合到一起 好吧，让我们开始使用这些新组件来写几个视图。 我们不再需要我们的JSONResponse教程里的views.py，所以删除它。完成后，我们可以开始重构我们的views。 from rest_framework import status from rest_framework.decorators import api_view from rest_framework.response import Response from snippets.models import Snippet from snippets.serializers import SnippetSerializer @api_view(['GET', 'POST']) def snippet_list(request): \"\"\" 列出所有snippets, 或者创建一个新的snippet. \"\"\" if request.method == 'GET': snippets = Snippet.objects.all() serializer = SnippetSerializer(snippets, many=True) return Response(serializer.data) elif request.method == 'POST': serializer = SnippetSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data, status=status.HTTP_201_CREATED) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) 我们的实例视图比前一个示例有所改进。它更简洁一些，如果我们使用Forms API，代码现在感觉非常相似。我们还使用了指定的状态代码，这使得响应的含义更加明显。 以下是views.py模块中单个snippet的视图。 @api_view(['GET', 'PUT', 'DELETE']) def snippet_detail(request, pk): \"\"\" Retrieve, update or delete a code snippet. \"\"\" try: snippet = Snippet.objects.get(pk=pk) except Snippet.DoesNotExist: return Response(status=status.HTTP_404_NOT_FOUND) if request.method == 'GET': serializer = SnippetSerializer(snippet) return Response(serializer.data) elif request.method == 'PUT': serializer = SnippetSerializer(snippet, data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) elif request.method == 'DELETE': snippet.delete() return Response(status=status.HTTP_204_NO_CONTENT) 这应该都非常熟悉 - 这与使用常规Django视图没有多大区别。 请注意，我们不再明确地将我们的请求或响应绑定到给定的内容类型.request.data可以处理传入的json请求，但它也可以处理其他格式。同样，我们使用数据返回响应对象，但允许REST框架将响应展示给我们正确的内容类型。 为我们的URL添加可选的格式后缀 为了利用我们的响应不再被硬连接到单一内容类型的事实，让我们将格式后缀的支持添加到我们的API端点。使用格式后缀给了我们明确引用给定格式的URL，并且意味着我们的API将能够处理诸如http://example.com/api/items/4.json之类的 URL 。 首先，在两个视图中添加一个format格式关键字参数，就像这样。 def snippet_list(request, format=None): and def snippet_detail(request, pk, format=None): 现在稍微更新snippets/urls.py文件，以附加一组format_suffix_patterns到现有的URL。 from django.conf.urls import url from rest_framework.urlpatterns import format_suffix_patterns from snippets import views urlpatterns = [ url(r'^snippets/$', views.snippet_list), url(r'^snippets/(?P[0-9]+)$', views.snippet_detail), ] urlpatterns = format_suffix_patterns(urlpatterns) 我们不一定需要添加这些额外的url模式，但是它提供了一种简单、干净的方式来引用特定的格式。 它看起来如何？ 继续从命令行测试API，就像我们在教程1中所做的那样。这些工作都非常类似，尽管如果我们发送无效请求，我们已经有了一些更好的错误处理。 我们可以像以前一样获取所有snippets的列表。 http http://127.0.0.1:8000/snippets/ HTTP/1.1 200 OK ... [ { \"id\": 1, \"title\": \"\", \"code\": \"foo = \\\"bar\\\"\\n\", \"linenos\": false, \"language\": \"python\", \"style\": \"friendly\" }, { \"id\": 2, \"title\": \"\", \"code\": \"print \\\"hello, world\\\"\\n\", \"linenos\": false, \"language\": \"python\", \"style\": \"friendly\" } ] 我们可以通过使用Accept header来控制返回的响应格式： http http://127.0.0.1:8000/snippets/ Accept:application/json # Request JSON http http://127.0.0.1:8000/snippets/ Accept:text/html # Request HTML 或者通过附加格式后缀访问： http http://127.0.0.1:8000/snippets.json # JSON suffix http http://127.0.0.1:8000/snippets.api # Browsable API suffix 同样，我们可以使用Content-Type标题来控制我们发送的请求的格式。 # POST using form data http --form POST http://127.0.0.1:8000/snippets/ code=\"print 123\" { \"id\": 3, \"title\": \"\", \"code\": \"print 123\", \"linenos\": false, \"language\": \"python\", \"style\": \"friendly\" } # POST using JSON http --json POST http://127.0.0.1:8000/snippets/ code=\"print 456\" { \"id\": 4, \"title\": \"\", \"code\": \"print 456\", \"linenos\": false, \"language\": \"python\", \"style\": \"friendly\" } 如果您添加--debug向上述http请求，您将能够在请求标头中看到请求的类型。 现在，通过访问http://127.0.0.1:8000/snippets/，在Web浏览器中打开API 。 浏览功能 因为API根据客户端请求选择响应的内容类型，所以默认情况下，当Web浏览器请求该资源时，它将返回HTML格式的资源。这允许API返回完全可以浏览网页的HTML表示。 拥有可浏览网页的API是一个巨大的可用性胜利，并且使开发和使用您的API变得更加容易。它也大大降低了想要检查和使用API​​的其他开发人员的进入门槛。 有关可浏览的API功能以及如何对其进行定制的更多信息，请参阅可浏览的API主题。 下一步是什么？ 在教程第3部分中，我们将开始使用基于类的视图，并了解通用视图如何减少编写的代码量。 "},"tutorial/classview.html":{"url":"tutorial/classview.html","title":"类视图","keywords":"","body":"类视图 我们也可以使用基于类的视图来编写API视图，而不是基于函数的视图。正如我们将看到的，这是一个强大的模式，可以让我们复用常用功能，并帮助我们保持代码干爽。 使用基于类的视图重写我们的API 我们将首先将根视图重写为基于类的视图。这些都涉及到重构views.py。 from snippets.models import Snippet from snippets.serializers import SnippetSerializer from django.http import Http404 from rest_framework.views import APIView from rest_framework.response import Response from rest_framework import status class SnippetList(APIView): \"\"\" List all snippets, or create a new snippet. \"\"\" def get(self, request, format=None): snippets = Snippet.objects.all() serializer = SnippetSerializer(snippets, many=True) return Response(serializer.data) def post(self, request, format=None): serializer = SnippetSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data, status=status.HTTP_201_CREATED) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) 到现在为止还挺好。它看起来与之前的用法非常相似，但我们在不同的HTTP方法做了更好的分离。我们还需要更新实例视图views.py。 class SnippetDetail(APIView): \"\"\" Retrieve, update or delete a snippet instance. \"\"\" def get_object(self, pk): try: return Snippet.objects.get(pk=pk) except Snippet.DoesNotExist: raise Http404 def get(self, request, pk, format=None): snippet = self.get_object(pk) serializer = SnippetSerializer(snippet) return Response(serializer.data) def put(self, request, pk, format=None): snippet = self.get_object(pk) serializer = SnippetSerializer(snippet, data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) def delete(self, request, pk, format=None): snippet = self.get_object(pk) snippet.delete() return Response(status=status.HTTP_204_NO_CONTENT) 这看起来不错。同样，它现在仍然非常类似基于函数的视图。 我们现在还需要稍微重构我们使用基于类的视图的snippets/urls.py。 from django.conf.urls import url from rest_framework.urlpatterns import format_suffix_patterns from snippets import views urlpatterns = [ url(r'^snippets/$', views.SnippetList.as_view()), url(r'^snippets/(?P[0-9]+)/$', views.SnippetDetail.as_view()), ] urlpatterns = format_suffix_patterns(urlpatterns) 使用mixins 使用基于类的视图的最大好处之一是，它允许我们轻松地编写可重用的行为片段。 到目前为止，我们使用的create/retrieve/update/delete操作对于我们创建的任何模型支持的API视图将非常相似。这些常见行为的某些部分在REST框架的mixin类中实现。 我们来看看如何使用mixin类组合视图。这是我们的views.py模块了。 from snippets.models import Snippet from snippets.serializers import SnippetSerializer from rest_framework import mixins from rest_framework import generics class SnippetList(mixins.ListModelMixin, mixins.CreateModelMixin, generics.GenericAPIView): queryset = Snippet.objects.all() serializer_class = SnippetSerializer def get(self, request, *args, **kwargs): return self.list(request, *args, **kwargs) def post(self, request, *args, **kwargs): return self.create(request, *args, **kwargs) 我们将花一点时间仔细检查这里发生了什么。我们正在构建我们的视图GenericAPIView，并添加ListModelMixin和CreateModelMixin。 基类提供核心功能，mixin类提供.list()和.create()操作。然后，我们明确地将方法get和post方法绑定到适当的操作。迄今为止足够简单的东西。 class SnippetDetail(mixins.RetrieveModelMixin, mixins.UpdateModelMixin, mixins.DestroyModelMixin, generics.GenericAPIView): queryset = Snippet.objects.all() serializer_class = SnippetSerializer def get(self, request, *args, **kwargs): return self.retrieve(request, *args, **kwargs) def put(self, request, *args, **kwargs): return self.update(request, *args, **kwargs) def delete(self, request, *args, **kwargs): return self.destroy(request, *args, **kwargs) 非常相似。同样，我们正在使用的GenericAPIView类来提供核心功能，并混入增加提供.retrieve()，.update()和.destroy()。 使用通用的基于类的视图 使用mixin类，我们重写了视图，使用比以前稍少的代码，但我们可以更进一步。REST框架提供了一组已经混合的通用视图，我们可以使用这些视图更多地修剪我们的views.py模块。 from snippets.models import Snippet from snippets.serializers import SnippetSerializer from rest_framework import generics class SnippetList(generics.ListCreateAPIView): queryset = Snippet.objects.all() serializer_class = SnippetSerializer class SnippetDetail(generics.RetrieveUpdateDestroyAPIView): queryset = Snippet.objects.all() serializer_class = SnippetSerializer Wow，这很简洁。我们免费获得了大量的代码，而且我们的代码看起来很好，干净，惯用的Django。 接下来，我们将转到本教程的第4部分，其中我们将介绍如何处理API的身份验证和权限。 "},"tutorial/auth-perms.html":{"url":"tutorial/auth-perms.html","title":"认证和权限","keywords":"","body":"认证和权限 目前我们的API没有任何限制对谁都可以编辑或删除代码。我们希望有一些更高级的行为来保证： 代码始终与创建者关联。 只有经过身份验证的用户才可以创建。 只有创建者可能会更新或删除它。 未经身份验证的请求应只具有完全只读访问权限。 将信息添加到我们的model 我们将对Snippet model类进行一些修改改。首先，我们添加几个字段。其中一个字段将用于表示创建Snippet的用户。其他字段将用于存储代码的突出显示的HTML表示。 将以下两个字段添加到Snippet模型中models.py。 owner = models.ForeignKey('auth.User', related_name='snippets', on_delete=models.CASCADE) highlighted = models.TextField() 我们还需要确保保存模型时，我们使用pygments代码高亮库来填充突出显示的字段。 我们需要一些额外的import： from pygments.lexers import get_lexer_by_name from pygments.formatters.html import HtmlFormatter from pygments import highlight 现在我们可以在.save()模型类中添加一个方法： def save(self, *args, **kwargs): \"\"\" 使用“pygments”库创建高亮的HTML。 \"\"\" lexer = get_lexer_by_name(self.language) linenos = self.linenos and 'table' or False options = self.title and {'title': self.title} or {} formatter = HtmlFormatter(style=self.style, linenos=linenos, full=True, **options) self.highlighted = highlight(self.code, lexer, formatter) super(Snippet, self).save(*args, **kwargs) 完成这些工作后，我们需要更新我们的数据库表。通常我们会创建一个数据库migration来完成这个任务，但为了本教程的目的，我们只需删除数据库并重新开始。 rm -f db.sqlite3 rm -r snippets/migrations python manage.py makemigrations snippets python manage.py migrate 您可能还想创建几个不同的用户，用于测试API。最快的方法是使用createsuperuser命令。 python manage.py createsuperuser 为我们的USER model添加端点 现在我们有一些用户可以使用，我们最好将这些用户的描述添加到我们的API中。创建一个新的序列化器是很容易的。在serializers.py添加： from django.contrib.auth.models import User class UserSerializer(serializers.ModelSerializer): snippets = serializers.PrimaryKeyRelatedField(many=True, queryset=Snippet.objects.all()) class Meta: model = User fields = ('id', 'username', 'snippets') 因为在用户模型上snippets是外键关系，所以在使用ModelSerializer类时它不会被默认包含，所以我们需要为它添加一个显式字段。 我们还会添加几个视图到views.py。我们只想为用户使用只读视图，因此我们将使用ListAPIView和RetrieveAPIView基于类的通用视图。 from django.contrib.auth.models import User class UserList(generics.ListAPIView): queryset = User.objects.all() serializer_class = UserSerializer class UserDetail(generics.RetrieveAPIView): queryset = User.objects.all() serializer_class = UserSerializer 确保导入UserSerializer from snippets.serializers import UserSerializer 最后，我们需要通过在URL conf中引用这些视图来将这些视图添加到API中。将以下内容添加到urls.py文件中。 url(r'^users/$', views.UserList.as_view()), url(r'^users/(?P[0-9]+)/$', views.UserDetail.as_view()), Snippets 与 Users 关联 现在，如果我们创建了一个snippets，那么会无法将创建snippets的用户与snippets实例关联起来。用户不是作为序列化描述的一部分发送的，而是作为传入请求的属性。 我们处理这个问题的方式是通过重写.perform_create()snippets视图上的方法，这允许我们修改实例保存的方式，并处理传入请求或请求URL中隐含的任何信息。 在SnippetList视图类中，添加以下方法： def perform_create(self, serializer): serializer.save(owner=self.request.user) 我们的序列化器的create()方法现在将传递一个额外的'owner'字段，以及来自请求的验证数据。 更新我们的序列化器 现在，snippet与创建它的用户相关联，让我们更新SnippetSerializer。将以下字段添加到序列化文件serializers.py中： owner = serializers.ReadOnlyField(source='owner.username') 注意:确保在内部元类的字段列表中添加owner。 这个领域正在做一件很有趣的事情。该source参数控制用于填充字段的属性，并且可以指向序列化实例上的任何属性。它也可以采用上面显示的虚线符号，在这种情况下，它将遍历给定的属性，就像使用Django的模板语言一样。 我们添加的字段是无类型的ReadOnlyField类，与其他类型的字段相比，例如CharField，BooleanField等等... untyped ReadOnlyField是只读的，并且将用于序列化表示，但它们被反序列化时不会用于更新模型当。我们也可以CharField(read_only=True)在这里使用。 为视图添加必要的权限 既然snippets与用户相关联，我们希望确保只有经过身份验证的用户才能创建、更新和删除snippets。 REST框架包含许多权限类，我们可以使用这些权限类来限制可以访问视图的用户。在这种情况下，我们正在寻找的是IsAuthenticatedOrReadOnly确保经过身份验证的请求获得读写访问权限，未经身份验证的请求获得只读访问权限。 首先在views文件中添加以下导入 from rest_framework import permissions 接着，下面的属性添加到SnippetList和SnippetDetail视图类。 permission_classes = (permissions.IsAuthenticatedOrReadOnly,) 添加登录到Browsable API 如果您现在打开浏览器并访问API，会发现您不能创建新的snippets。为了创建，我们需要能够以用户身份登录。 我们可以通过编辑项目级urls.py文件中的URLconf来添加API的登录视图。 在文件顶部添加以下导入： from django.conf.urls import include 并且，在文件末尾，添加一个包含可访问API的登录和注销视图。 urlpatterns += [ url(r'^api-auth/', include('rest_framework.urls')), ] 现在，如果您再打开浏览器并刷新页面，则会在页面右上方看到一个“login”链接。如果您以前创建的用户之一登录，则可以再次创建新的snippets。 一旦创建了几个代码片段，请访问```'/ users /'```url，并注意每个用户的“snippets”字段中与每个用户关联的代码段ID列表。 ## 对象级权限 实际上，我们希望所有人都可以看到所有snippets，但也要确保只有创建snippets的用户才能更新或删除它。 为此，我们需要创建一个自定义权限。 在snippets应用程序中，创建一个新文件， ```permissions.py from rest_framework import permissions class IsOwnerOrReadOnly(permissions.BasePermission): \"\"\" Custom permission to only allow owners of an object to edit it. \"\"\" def has_object_permission(self, request, view, obj): # Read permissions are allowed to any request, # so we'll always allow GET, HEAD or OPTIONS requests. if request.method in permissions.SAFE_METHODS: return True # Write permissions are only allowed to the owner of the snippet. return obj.owner == request.user 现在我们可以通过编辑views类的permission_classes属性来将该自定义权限添加到我们的snippets实例SnippetDetail： permission_classes = (permissions.IsAuthenticatedOrReadOnly, IsOwnerOrReadOnly,) 确保也要导入IsOwnerOrReadOnly。 from snippets.permissions import IsOwnerOrReadOnly 现在，如果您再次打开浏览器，如果您以创建snippets的相同用户身份登录，则会发现'DELETE'和'PUT'操作仅出现在代码片段实例端点上。 使用API​​进行身份验证 因为我们现在对API有一组权限，如果我们想要编辑任何snippets，我们需要验证对它的请求。我们还没有设置任何认证类，默认是当前应用的，它们是SessionAuthentication和BasicAuthentication。 当我们通过网络浏览器访问API时，然后浏览器会话将为请求提供所需的身份验证，我们就可以登录了。 如果我们正在以编程方式与API进行交互，那么我们需要在每个请求上明确提供身份验证凭据。 如果我们尝试创建一个没有进行身份验证的snippets，我们会得到一个错误： http POST http://127.0.0.1:8000/snippets/ code=\"print 123\" { \"detail\": \"Authentication credentials were not provided.\" } 我们可以通过添加我们之前创建的用户和密码来验证成功的请求。 http -a admin:password123 POST http://127.0.0.1:8000/snippets/ code=\"print 789\" { \"id\": 1, \"owner\": \"admin\", \"title\": \"foo\", \"code\": \"print 789\", \"linenos\": false, \"language\": \"python\", \"style\": \"friendly\" } 概要 现在我们已经在我们的Web API上获得了相当细致的权限集合，以及系统用户和他们创建的snippets的终点。 在本教程的第5部分中，我们将研究如何通过为突出显示的片段创建HTML端点来将所有内容绑定在一起，并通过对系统内的关系使用超链接来提高API的凝聚力。 "},"tutorial/hyperlink.html":{"url":"tutorial/hyperlink.html","title":"关系和超链接","keywords":"","body":"关系和超链接 目前，我们的API中的关系用主键表示。在本教程的这一部分中，我们将通过使用超链接来提高API的内聚性和可发现性 为我们的API的根创建一个endpoint 现在我们有'snippets'和'users'的端点，但是我们没有一个入口指向我们的API。要创建一个，我们将使用一个常规的基于函数的视图和我们之前介绍的装饰器@api_view。在你的snippets/views.py添加中： from rest_framework.decorators import api_view from rest_framework.response import Response from rest_framework.reverse import reverse @api_view(['GET']) def api_root(request, format=None): return Response({ 'users': reverse('user-list', request=request, format=format), 'snippets': reverse('snippet-list', request=request, format=format) }) 这里应该注意两件事。首先，我们使用REST框架的reverse函数来返回完全限定的URL; 其次，URL模式通过方便的名称来标识，我们稍后会在我们的网站中声明snippets/urls.py。 为高亮的snippets创建一个endpoint 我们的pastebin API仍然存在的另一个显而易见的问题是突出端点的代码。 与其他所有API端点不同，我们不想使用JSON，而只是呈现HTML表示。REST框架提供了两种HTML呈现器，一种用于处理使用模板展现的HTML，另一种用于处理预展现的HTML。第二个渲染器是我们希望用于此endpoint的渲染器。 在创建代码高亮显示视图时，我们需要考虑的另一件事是没有现有的具体的通用视图可以使用。我们不是返回一个对象实例，而是返回一个对象实例的属性。 我们不使用具体的通用视图，而是使用基类来表示实例，并创建我们自己的.get()方法。在你的snippets/views.py添加中： from rest_framework import renderers from rest_framework.response import Response class SnippetHighlight(generics.GenericAPIView): queryset = Snippet.objects.all() renderer_classes = (renderers.StaticHTMLRenderer,) def get(self, request, *args, **kwargs): snippet = self.get_object() return Response(snippet.highlighted) 像之前一样，我们需要将我们创建的新视图添加到我们的URLconf中。我们将在我们的新API根中添加一个网址格式snippets/urls.py： url(r'^$', views.api_root), 然后为代码高亮添加一个网址格式： url(r'^snippets/(?P[0-9]+)/highlight/$', views.SnippetHighlight.as_view()), 超链接我们的API 处理实体之间的关系是Web API设计中更具挑战性的方面之一。我们可以选择代表一种关系的方式有很多种： 使用主键。 在实体之间使用超链接。 在相关实体上使用唯一标识段落字段。 使用相关实体的默认字符串表示形式。 将相关实体嵌套在父代表中。 一些其他自定义表示。 REST框架支持这些所有的样式，并且可以跨前向或反向关系应用它们，或者将其应用到自定义管理器（如通用外键）中。 在这种情况下，我们希望在实体之间使用超链接样式。为了做到这一点，我们将修改序列化器来扩展HyperlinkedModelSerializer而不是现有的序列化器ModelSerializer。 * 它id默认不包含该字段。 * 它包括一个url字段，使用HyperlinkedIdentityField。 * 关系使用HyperlinkedRelatedField，而不是PrimaryKeyRelatedField。 我们可以轻松地重写我们现有的序列化程序来使用超链接。在你的```snippets/serializers.py```中添加： ```python class SnippetSerializer(serializers.HyperlinkedModelSerializer): owner = serializers.ReadOnlyField(source='owner.username') highlight = serializers.HyperlinkedIdentityField(view_name='snippet-highlight', format='html') class Meta: model = Snippet fields = ('url', 'id', 'highlight', 'owner', 'title', 'code', 'linenos', 'language', 'style') class UserSerializer(serializers.HyperlinkedModelSerializer): snippets = serializers.HyperlinkedRelatedField(many=True, view_name='snippet-detail', read_only=True) class Meta: model = User fields = ('url', 'id', 'username', 'snippets') 请注意，我们还添加了一个新'highlight'字段。该字段与url字段的类型相同，只是它指向的是'snippet-highlight'url模式，而不是'snippet-detail'url模式。 由于我们已经包含格式后缀的URL '.json'，我们还需要在highlight字段上指明它返回的任何格式后缀超链接应使用'.html'后缀。 确保我们的URL模式被命名 如果我们要有超链接的API，我们需要确保我们命名我们的URL模式。我们来看看我们需要命名的URL模式。 我们的API的根源是'user-list'和'snippet-list'。 我们的片段序列化程序包含一个指向的字段'snippet-highlight'。 我们的用户序列化程序包含一个指向的字段'snippet-detail'。 我们的片段和用户序列化程序包含'url'默认情况下会引用的字段，'{model_name}-detail'在这种情况下将是'snippet-detail'和'user-detail'。 将所有这些名称添加到我们的URLconf后，我们的最终snippets/urls.py文件应该如下所示： from django.conf.urls import url, include from rest_framework.urlpatterns import format_suffix_patterns from snippets import views # API endpoints urlpatterns = format_suffix_patterns([ url(r'^$', views.api_root), url(r'^snippets/$', views.SnippetList.as_view(), name='snippet-list'), url(r'^snippets/(?P[0-9]+)/$', views.SnippetDetail.as_view(), name='snippet-detail'), url(r'^snippets/(?P[0-9]+)/highlight/$', views.SnippetHighlight.as_view(), name='snippet-highlight'), url(r'^users/$', views.UserList.as_view(), name='user-list'), url(r'^users/(?P[0-9]+)/$', views.UserDetail.as_view(), name='user-detail') ]) 添加分页 用户和snippets的列表视图可能会返回很多实例，所以我们确实要确保对结果进行分页，并允许API客户端遍历每个单独的页面。 通过tutorial/settings.py稍微修改我们的文件，我们可以更改默认列表样式以使用分页。添加以下设置： REST_FRAMEWORK = { 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 10 } 请注意，REST框架中的设置都被命名为一个单独的字典设置REST_FRAMEWORK，这有助于使它们与其他项目设置保持良好的分离。 如果我们也需要，我们也可以自定义分页样式，但在这种情况下，我们会坚持默认。 浏览API 如果我们打开一个浏览器并导航到可浏览的API，您会发现现在您可以通过简单的链接访问API。 您还可以看到片段实例上的“highlight”链接，这会将您带到突出显示的代码HTML表示。 在本教程的第6部分中，我们将介绍如何使用ViewSets和routers来减少构建API所需的代码量。 "},"tutorial/routers.html":{"url":"tutorial/routers.html","title":"视图集合和路由","keywords":"","body":"视图集合和路由 REST框架包含一个用于处理的抽象概念ViewSets，它允许开发人员专注于对API的状态和交互进行建模，并根据通用约定自动处理URL构造。 ViewSet类与类几乎相同View，除了它们提供例如read或update的操作，而不是例如get``` orput``的方法处理程序。 一个视图集合类只在最后时刻绑定到一组方法来处理程序，当它被实例化为一组视图时，通常通过使用一个Router类来为您处理定义URL conf的复杂性。 重构视图 我们来看看我们当前的一组视图，并将它们重构为视图集。 首先，让我们将UserList和UserDetail视图重构为单个UserViewSet。我们可以删除这两个视图，并用一个类替换它们： from rest_framework import viewsets class UserViewSet(viewsets.ReadOnlyModelViewSet): \"\"\" 这个视图集合会自动提供“list”和“detail”操作。 \"\"\" queryset = User.objects.all() serializer_class = UserSerializer 这里我们使用这个ReadOnlyModelViewSet类来自动提供默认的“只读”操作。我们仍然像在使用常规视图时那样设置queryset和serializer_class属性，但是我们不再需要向两个单独的类提供相同的信息。 接下来我们要更换SnippetList，SnippetDetail和SnippetHighlight视图类。我们可以删除三个视图，并再次用一个类替换它们。 from rest_framework.decorators import detail_route from rest_framework.response import Response class SnippetViewSet(viewsets.ModelViewSet): \"\"\" 该视图自动提供 `list`, `create`, `retrieve`, `update` and `destroy` actions. Additionally we also provide an extra `highlight` action. \"\"\" queryset = Snippet.objects.all() serializer_class = SnippetSerializer permission_classes = (permissions.IsAuthenticatedOrReadOnly, IsOwnerOrReadOnly,) @detail_route(renderer_classes=[renderers.StaticHTMLRenderer]) def highlight(self, request, *args, **kwargs): snippet = self.get_object() return Response(snippet.highlighted) def perform_create(self, serializer): serializer.save(owner=self.request.user) 这次我们使用这个ModelViewSet类来获得完整的默认读写操作。 请注意，我们也使用@detail_route装饰器来创建一个名为的自定义操作highlight。这个装饰器可以用来添加任何不符合标准create/ update/ delete风格的自定义端点。 使用@detail_route 装饰器的自定义操作将在默认情况下响应GET请求。如果我们想要一个响应POST请求的操作，我们可以使用methods参数。 自定义操作的URL默认取决于方法名称本身。如果你想改变构造url的方式，你可以包含url_path作为装饰器关键字参数。 显式地将ViewSets绑定到URL 当我们定义URLConf时，处理程序方法只绑定到操作。为了查看引擎盖下发生了什么，让我们首先从我们的视图中显式地创建一组视图。 在snippets/urls.py文件中，我们将我们的ViewSet类绑定到一组具体的视图中。 from snippets.views import SnippetViewSet, UserViewSet, api_root from rest_framework import renderers snippet_list = SnippetViewSet.as_view({ 'get': 'list', 'post': 'create' }) snippet_detail = SnippetViewSet.as_view({ 'get': 'retrieve', 'put': 'update', 'patch': 'partial_update', 'delete': 'destroy' }) snippet_highlight = SnippetViewSet.as_view({ 'get': 'highlight' }, renderer_classes=[renderers.StaticHTMLRenderer]) user_list = UserViewSet.as_view({ 'get': 'list' }) user_detail = UserViewSet.as_view({ 'get': 'retrieve' }) 请注意，我们是如何从每个ViewSet类创建多个视图，方法是将http方法绑定到每个视图所需的操作。 现在我们已经将资源绑定到具体的视图中，我们可以像往常一样从URL conf注册视图。 urlpatterns = format_suffix_patterns([ url(r'^$', api_root), url(r'^snippets/$', snippet_list, name='snippet-list'), url(r'^snippets/(?P[0-9]+)/$', snippet_detail, name='snippet-detail'), url(r'^snippets/(?P[0-9]+)/highlight/$', snippet_highlight, name='snippet-highlight'), url(r'^users/$', user_list, name='user-list'), url(r'^users/(?P[0-9]+)/$', user_detail, name='user-detail') ]) 使用路由器 因为我们使用的是ViewSet类而不是View类，所以我们实际上不需要自己设计URL。将资源连接到视图和URL可以使用Router类自动处理。我们所需要做的就是用路由器注册适当的视图集，然后让其完成。 这是我们重新连接的snippets/urls.py文件。 from django.conf.urls import url, include from rest_framework.routers import DefaultRouter from snippets import views # Create a router and register our viewsets with it. router = DefaultRouter() router.register(r'snippets', views.SnippetViewSet) router.register(r'users', views.UserViewSet) # The API URLs are now determined automatically by the router. urlpatterns = [ url(r'^', include(router.urls)) ] 向路由器注册视图类似于提供urlpattern。我们包含两个参数 - 视图的URL前缀和视图本身。 DefaultRouter我们使用的类也为我们自动创建了API根视图，因此我们现在可以api_root从views模块中删除该方法。 视图与视图集之间的权衡 使用viewsets是一个非常有用的抽象。它有助于确保URL约定在您的API中是一致的，最小化您需要编写的代码量，并允许您集中精力于API提供的交互和表示，而不是URL conf的细节。 这并不意味着它总是正确的方法。在使用基于类的视图而不是基于功能的视图时，有一组类似的折衷方案。使用viewset比单独构建视图更不明确。 在本教程的第7部分中，我们将介绍如何添加API模式，以及如何使用客户端库或命令行工具与我们的API进行交互。 "},"tutorial/coreapi.html":{"url":"tutorial/coreapi.html","title":"coreapi","keywords":"","body":"coreapi "},"api/requests.html":{"url":"api/requests.html","title":"Requests","keywords":"","body":"Requests 如果你基于REST做一些web应用，那么你应该忽略request.POST.—— Malcom Tredinnick REST framework的Request类是标准的HttpRequest的扩展(并不是类继承)，增加了更加灵活的请求处理和请求认证。 Request 解析 REST framework的Request对象提供了非常灵活的请求解析处理，无论是JSON数据格式还是其他类型的数据格式，Request对象都会用同样的方式来处理所有的表单数据。 .data request.data返回的是经过处理后的request body的内容。这和标准的request.POST和request.FILES属性是类似的，除此之外，还有以下特性： 包含所有解析的内容，包含file和non-file的输入 它支持解析\b除了POST以外其他的HTTP方法的内容，\b这意味着你可以访问PUT和PATCH的请求 它支持REST framework灵活的请求解析，不只是简简单单的表单处理。比如，处理JSON\b数据和处理表单数据是一样的。 更多的解析，查看文档 解析处理 .query_params request.query_params 对于标准的request.GET是一个更加正确的命名方式。 为了代码更加的清晰，我们建议您使用request.query_params来代替Django标准的request.GET方法。 这样做能保证代码更加正确且清晰，因为所有的HTTP方法都会包含有请求参数，而不仅仅是GET方法。 .parsers REST中的APIView类或者是@api_view装饰器会确保.parsers属性\b正确的设置为一个list。这个list包含一组Parser实例。 这些Parser实例是基于view中的parser_classes或者全局的DEFAULT_PARSER_CLASSES设置。 通常情况下不会访问这个属性。 可以查看rest_framework.view.APIView类中的get_parsers方法。\b有多少个对象list中就会有多少个Parser实例。 注意： 如果客户端发送的是一个\b畸形的内容，那么访问request.data可能会抛出ParseError异常。默认的REST framework的APIView类或者是api_view装饰器会捕捉\b错误，并返回一个400 Bad Request响应。 如果客户端\b发送请求并携带content-type，REST framework不能解析，那么会抛出UnsupportedMediaType异常，REST 会捕捉这个异常，并返回415 Unsupported Media Type响应。 内容协商 REST framework中的request还暴露了一些方法允许通过协商来决定结果。也就是说，这允许你自己实现一些行为，比如给不同的数据类型一个不同的序列化方案。 源码位置： rest_framework.view.APIView类中的perform_content_negotiation方法。 .accepted_renderer 这是在内容协商过程中允许选择的渲染实例。 accepted_media_type 这个字符串代表在内容协商过程中允许的类型。 认证 REST framework为认证提供了非常灵活的需求： 在不同API部分可以使用不同的认证策略 支持使用多种认证策略 对进来的请求提供关联的用户和Token信息 .user REST framework中的request.user是django.contrib.auth.models.User返回的一个实例。这个行为取决于使用的认证策略。 如果请求是未认证的，那么request.user返回的是django.contrib.auth.models.AnonymousUser的实例。 更多详情查看 认证中心 .auth REST framework中的request.auth 会返回任何附加的认证上下文。准确的说这依赖于所使用的认证策略。通常，可能会是已经认证的用户的Token实例。 如果请求未认证，或者说没有额外\b附加的上下文，那么request.auth将返回None。 更多详情查看 认证中心 .authenticators REST framework中的APIView类或者api_view装饰器会\b确保这个数据自动的被设置。这个属性是一个由Authentication实例组成的list。 这些Authentication实例基于view中定义的authentication_classes或者是全局的DEFAULT_AUTHENTICATORS的设置。 同样的，通常不需要访问这个属性。 源码位置：rest_framework.view.APIView类中的get_authenticators方法。 注意： 当调用.user或者.auth属性的时候，你可能会看到WrappedAttributeError异常。 浏览器增强 REST framework支持一些增强的浏览器，比如基于浏览器表单的PUT、PATCH和DELETE。 .method REST framework中的request.method会返回请求的HTTP方法的大写字符串。 基于浏览器的PUT、PATCH和DELETE也支持。 更多信息查看 浏览器增强 .content_type \bREST framework中的request.content_type返回一个字符串对象，表示当前请求的内容主体的类型(media type of the HTTP request's body)。如果没有提供，那么返回空。 通常不需要直接访问请求内容的类型，大多数情况REST framework默认的行为就够用了。 如果你\b真的需要访问请求内容的类型，那么应该使用.content_type而不是request.META.get('HTTP_CONTENT_TYPE')。因为.content_type透明的支持基于浏览器的non-form内容。 更多信息查看 浏览器增强 .stream `REST framework中的``request.stream```返回一个stream代表请求主体的内容。 通常不需要直接访问请求内容的类型，大多数情况REST framework默认的行为就够用了。 标准的HttpRequest属性 REST framework的Request作为标准的Django的HttpRequest扩展，\b肯定的一点是Django标准的属性和方法都可以正常使用。比如request.META和request.session都能正常的使用。 注意： REST framework的Request并不是Django的HttpRequest类的继承。 "},"api/responses.html":{"url":"api/responses.html","title":"Responses","keywords":"","body":"Responses 与基本的HttpResponse 对象不同，TemplateResponse 对象会记住视图提供的模板和上下文的详细信息来计算响应。 响应的最终结果在后来的响应处理过程中直到需要时才计算。——Django 官方文档 点击这里查看官方文档 REST framework支持HTTP内存的协商通过给定的Response类，你返回的内容可以渲染成多种content type，这依赖于客户端的请求。 这里的Response是Django的SimpleTemplateResponse的子类。REST framework使用标准的HTTP内容协商来确定最终返回的内容应该如何被渲染。 对于Response类并不是强制使用的，如果需要的话，你可以从你的视图中返回一个常规的HttpResponse或者是StreamingHttpResponse对象。使用Response仅是提供了一个方便的接口用于返回多种多样的格式的响应数据。 除非你出于某些原因想定制化开发REST framework，否则你应该总是使用APIView类或者是@api_view函数，为你的视图返回一个Response对象。这样做可以在你的视图返回结果之前，来确定视图执行内容协商并且选择恰当合适的渲染器来渲染响应结果。 关于SimpleTemplateResponse的参考链接，点这里。 创建Response Response() 初始化语法： Response(self, data=None, status=None, template_name=None, headers=None, exception=False, content_type=None) 和常规的HttpResponse对象不同，你不需要传入一个已经渲染的内容来实例化Response对象。相反你传递的是一个未渲染的数据。 即使Response类使用渲染器也并不能处理复杂的数据类型，比如Django Model实例类型。所以在创建Response对象之前，你需要序列化数据为原始的数据类型。 你可以使用REST framework的Serializer类来处理数据的序列化，或者使用你自定义的序列化器。 参数： data: 用于response的已经序列的数据 status: 用于response的状态码 template_name: 如果HTMLRenderer被选择，那么使用这个模板来渲染数据 headers: 一个字典，用于在response中的HTTP头 content_type: 用于response的content type。通常，这是有渲染器通过内容协商自动设定。有一些特殊的情况可以显示的指定内容类型。 属性 .data 未渲染的，已经序列化的响应数据。 .status_code HTTP响应代码。 .content 已经渲染的内容。如果要调用.render()方法，那么.content必须要可以被访问。 .template_name 如果指定了，这显示指定的模板名。 .accepted_renderer 渲染器(renderer)实例，用于渲染响应结果。 由APIView或者是@api_view自动设置。 .accepted_media_type 在内容协商阶段确定的媒体类型(media type)。 由APIView或者是@api_view自动设置。 .renderer_context 将要传递给渲染器的.render()方法的一个额外的上下文信息。是一个字典。 由APIView或者是@api_view自动设置。 标准的HttpResponse属性 REST framework中的Response是Django原生的SimpleTemplateResponse的扩展。所以标准的属性和方法都可以使用。比如你可以使用标准的方法设置响应头： response = Response() response['Cache-Control'] = 'no-cache' .render() 初始化语法： .render() 这个方法被调用用于将响应的序列化数据渲染到最终的响应内容中。当.render()被调用，响应内容被设置，调用.render(data, accepted_media_type, renderer_context)方法，在accepted_renderer实例中。 通常你不需要自己去调用.render()。 参考链接： https://docs.djangoproject.com/en/2.0/ref/template-response/ "},"api/views.html":{"url":"api/views.html","title":"视图Views","keywords":"","body":"视图Views 基于类的视图 Django的基于类的视图和老式视图相比是更受欢迎的。——Reinout van Rees REST framework提供了一个APIView类，是Django的View类的子类。 相比于常规的View类，REST framework的APIView有以下几点不同： 传递给处理方法的请求是REST framework的Request实例，而不是Django的HttpRequest实例。 处理方法可能返回REST framework的Response来代替Django的HttpResponse。该视图将会管理内容协商并给响应设置正确的渲染器。 任何异常将会被APIException捕捉，并且返回一个合适的响应。(包含一个合适的错误提示) 任何进入的请求，在派分到处理函数之前，都将是已经认证的，并且有适当的权限，或者还会有节流的检查。 使用APIView类基本上跟使用常规的View是基本一样的。像往常一样，进来的请求会被分派到适当的处理函数中，比如.get()或者是.post()。此外，还可以设置大量的属性，用来控制API策略的方方面面。 from rest_framework.views import APIView from rest_framework.response import Response from rest_framework import authentication, permissions from django.contrib.auth.models import User class ListUsers(APIView): \"\"\" 列出系统中所有的用户. * 需要进行Token验证. * 仅仅只有管理才可以访问这个视图. \"\"\" authentication_classes = (authentication.TokenAuthentication,) permission_classes = (permissions.IsAdminUser,) def get(self, request, format=None): \"\"\" Return a list of all users. \"\"\" usernames = [user.username for user in User.objects.all()] return Response(usernames) 注意: 刚开始可能会觉得Django REST Framework的APIView和GenericAPIView和各种各样的Mixins和Viewsets有非常多的方法，属性和关系。这里有一个在线的地址，Classy Django REST Framework提供了一个可以浏览的资源，包含完整的方法和属性，对于Django REST Framework的基于类的视图。 API策略 属性 以下属性用于控制API视图的方方面面, 这些属性都是可插拔的。 .renderer_classes .parser_classes .authemtication_classes .throttle_classes .permission_classes .content_negotiation_class API策略 实例方法 REST framework 会使用下面的方法 去实例化 各种可插拔的 API 策略。 通常情况你不需要重写这些方法。 .get_renderers(self) .get_parsers(self) .get_authenticators(self) .get_throttles(self) .get_permissions(self) .get_content_negotiator(self) .get_exception_handler(self) API策略 实施方法 在REST framework 把请求分发到相应的处理函数之前，会调用下面的方法。 .check_permissions(self, request) .check_throttles(self, request) .perform_content_negotiation(self, request, force=False) Dispatch 分派方法 下面的这些方法会直接被视图的.dispatch()方法来调用。在调用处理函数(比如 .get(), .post(), .put(), .patch())之前或者之后执行一些动作。 .initial(self, request, *args, **kwargs) 不管执行任何动作的处理函数之前，这个方法都会被首先调用。这个方法用来执行权限和限流功能，并且勇于处理内容协商。 你通常不需要修改这个方法。 .handle_exception(self, exc) 执行处理函数中抛出的任何异常都会被传递到这个方法中，该方法将会返回一个Response实例，或者重新raise一个异常。 默认处理异常的行为可以是任何rest_framework.exceptions.APIException的子类，和Django的Http404和PermissionDenied异常一样， 都会返回一个合理恰当的错误响应。 如果你需要在你的API中自定义错误响应，你应该在你继承的子类中重写该方法。 .initialize_request(self, request, *args, **kwargs) 初始化请求。 确保传递给处理方法的请求对象是Request的实例，而不是常规的Django的HttpRequest。 该方法实际上就是返回一个Request的实例。 你通常不需要修改这个方法。 .finalize_response(self, request, response, *args, **kwargs) 返回最终的响应对象。 该方法会在最后调用，确保处理函数返回的任何Response对象会被正确的渲染。 该方法会通过内容协商(self.perform_content_negotiation(request, force=True))，确定response.accepted_renderer和response.accepted_media_type。 你通常也不需要修改这个方法。 基于函数的视图 基于类的视图是一个优越的解决方案，这是一个误解。 ——Nick Coghlan REST framework对于基于函数的视图同样也能非常好的工作。REST framework提供了一组简单的装饰器，用来包装你的基于函数的视图；来保证你的视图接收到的请求是Request的实例(而不是Django的HttPRequest)，并且返回的响应是Response的实例(而不是Django的HttpResponse)，并且允许您配置如何处理请求。 @api_view() 语法： @api_view(http_method_names=['GET']) 核心功能就是@api_view装饰器，并且要把你视图应该接收处理的HTTP方法以列表的形式，写到装饰器的参数中。 比如，下面的例子是如何编写一个非常简单的视图，并且仅仅是手动返回一些数据： from rest_framework.decorators import api_view @api_view() def hello_world(request): return Response({\"message\": \"Hello, world!\"}) 这个视图将使用settings中指定的默认的渲染器，解析器和身份认证类。 默认情况只有GET方法会被允许。其他方法将会返回\"405 Method Not Allowed\"。如果要改变这种行为，需要指定视图允许哪些方法，比如下面这段代码： @api_view(['GET', 'POST']) def hello_world(request): if request.method == 'POST': return Response({\"message\": \"Got some data!\", \"data\": request.data}) return Response({\"message\": \"Hello, world!\"}) API策略 装饰器 REST framework提供了其他的装饰器，用于给你的视图增加一些设置，用于覆盖默认的设置。 这必须放置在@api_view装饰器的下面。 比如，限制(限流)的视图每天每个用户只可以访问一次，可以使用装饰器@throttle_classes，并把限制策略类以列表的形式传递给这个装饰器： from rest_framework.decorators import api_view, throttle_classes from rest_framework.throttling import UserRateThrottle class OncePerDayUserThrottle(UserRateThrottle): rate = '1/day' @api_view(['GET']) @throttle_classes([OncePerDayUserThrottle]) def view(request): return Response({\"message\": \"Hello for today! See you tomorrow!\"}) 这些装饰器对应APIView中设置的子类，他们功能是一样的。 可用的装饰器如下： @renderer_classes(...) @parser_classes(...) @authentication_classes(...) @throttle_classes(...) @permission_classes(...) 每个装饰器，至少接收一个类型为list或者tuple的参数，并且元素是一个类。 视图schema 装饰器 如果要给基于函数的视图，覆盖默认的schema生成，你可以使用@schema装饰器，同样的，这个装饰器必须在@api_view装饰器的下面。 比如： from rest_framework.decorators import api_view, schema from rest_framework.schemas import AutoSchema class CustomAutoSchema(AutoSchema): def get_link(self, path, method, base_url): # override view introspection here... @api_view(['GET']) @schema(CustomAutoSchema()) def view(request): return Response({\"message\": \"Hello for today! See you tomorrow!\"}) 这个装饰器的参数是一个AutoSchema的实例。具体参考文档schemas。当然你也可以传递一个None，比如： @api_view(['GET']) @schema(None) def view(request): return Response({\"message\": \"Will not appear in schema!\"}) 参考链接： http://www.cdrf.co/ "},"api/gviews.html":{"url":"api/gviews.html","title":"通用视图Generic views","keywords":"","body":"通用视图Generic views Django 的通用视图建立在基础视图之上，用于作为经常用到的功能的快捷方式，例如显示对象的详细信息。它们提炼视图开发中常见的风格和模式并将它们抽象，这样你可以快速编写常见的视图而不用重复你自己。—— Django 官方文档(内置的基于类的视图API) 点击这里查看官方文档。 基于类的视图，最大的好处之一就是他将允许你编写可以重用的行为。REST framework利用这一个有点提供了一些预先构建好的视图，这些视图提供了常用的模式。 REST framework提供的通用视图允许你快速的来构建一个和你的数据库紧密映射的一个API视图。 如果REST framework提供的通用视图不能够满足你的API需求，你可以使用更底层的APIView类。或者重新使用mixins和通用视图基类来重新编写一个你自己的可以重复使用的通用视图类。 例子 通常使用通用视图类的时候，你仅仅需要设置一些类属性即可： from django.contrib.auth.models import User from myapp.serializers import UserSerializer from rest_framework import generics from rest_framework.permissions import IsAdminUser class UserList(generics.ListCreateAPIView): queryset = User.objects.all() serializer_class = UserSerializer permission_classes = (IsAdminUser,) 对于更复杂的场景，你可能还想要覆盖视图类中的各种方法，比如下面： class UserList(generics.ListCreateAPIView): queryset = User.objects.all() serializer_class = UserSerializer permission_classes = (IsAdminUser,) def list(self, request): # Note the use of `get_queryset()` instead of `self.queryset` queryset = self.get_queryset() serializer = UserSerializer(queryset, many=True) return Response(serializer.data) 在极简单的情况下，你可能只需要通过.as_view()传递给类一些属性就可以了。比如，在你的URLconf中可能会包含如下的代码： url(r'^/users/', ListCreateAPIView.as_view(queryset=User.objects.all(), serializer_class=UserSerializer), name='user-list') API 参考 GenericAPIView 类 源码位置： rest_framework.generics.GenericAPIView 这个类是所有具名通用视图的基础类。 这个类扩展了REST framework的APIView类，为标准的list视图和detail视图添加了一些必要的行为。 每个提供给用户使用的具体的命名通用视图，是使用内置的GenericAPIView和一个或者多个的Mixins类组合而成的。具体的下面有介绍。 属性 基础设置: 下面的属性，控制基础的视图行为。 queryset: —— 用于从视图返回对象。通常情况下，你必须要设置这个属性或者是重写get_queryset()方法。如果你重写了视图的方法，一定要记住，不能直接访问这个属性，而是要调用get_queryset()方法； 因为queryset属性，只会评估计算一次，为后续所有的请求提供结果。 serializer_class: —— 这个属性设置的类，将用于验证用户的输入并反序列化，或者序列化输出结果。通常你需要设置这个属性，或者是重写get_serializer_class()方法。 lookup_field: —— 这是一个模型字段，用来执行单个的模型实例的对象查看(意思是，外键查看)。默认是'pk'。注意，当使用超链接的API，你需要确保API视图和序列化类设置lookup字段，如果你需要使用一个自定义的值。 lookup_url_kwarg: —— 被应用于对象查找URL关键字参数。URLconf中应包括相应于该值的关键字参数。如果未设置，那么默认使用和lookup_field相同的值。 分页设置: 下面的属性被用于当使用list视图的时候来控制分页。 pagination_class: —— 用于给list视图结果分页。默认使用的是settings中的DEFAULT_PAGINATION_CLASS选项，选项结果是'rest_framework.pagination.PageNumberPagination'。 设置pagination_class=None将会禁用该视图的分页。 注意： 在使用Django REST Framework 3.7.7版本的过程中，该分页设置为None，也就是默认没有分页效果。 默认设置位置: rest_framework.settings.DEFAULTS.DEFAULT_PAGINATION_CLASS 关于分页类的源码位置: rest_framework.pagination.*Pagination 过滤设置: filter_backends: —— 可以用来过滤Queryset的过滤类的一个列表。默认值是settings中的DEFAULT_FILTER_BACKENDS选项。 注意： 在使用Django REST Framework 3.7.7版本的过程中，该过滤设置为()。 方法 基础方法: 方法1：get_queryset(self) 返回list视图所需要的queryset(查询结果集)，并且可以用于detail视图的查询基础。默认情况下返回的是queryset属性指定的查询结果集。 应该总是使用get_queryset()方法而不是直接使用self.queryset来获取查询结果集。因为self.queryset仅仅计算一次，并且这些结果被缓存用于所有后续的请求。 在某些情况下，你可能要重写这个方法，用来适应动态的请求，比如，为每个当前访问的用户返回特定的结果集。代码如下: def get_queryset(self): user = self.request.user return user.accounts.all() 方法2：get_object(self) 返回用于detail视图的一个实例对象。默认使用lookup_field参数来过滤基础查询集。 在某些情况下，你可能要重写这个方法，用来提供更复杂的行为，比如基于多个URL kwarg的对象查询。代码如下： def get_object(self): queryset = self.get_queryset() filter = {} for field in self.multiple_lookup_fields: filter[field] = self.kwargs[field] obj = get_object_or_404(queryset, **filter) self.check_object_permissions(self.request, obj) return obj 注意，如果你的API不包含任何对象级别的权限，你完全不需要self.check_object_permissions，只需要从get_object_or_404查找返回对象即可。 方法3：filter_queryset(self, queryset) 给定一个查询结果集，然后过滤器会处理该查询结果集，最后返回一个新的queryset查询结果集。 比如： def filter_queryset(self, queryset): filter_backends = (CategoryFilter,) if 'geo_route' in self.request.query_params: filter_backends = (GeoRouteFilter, CategoryFilter) elif 'geo_point' in self.request.query_params: filter_backends = (GeoPointFilter, CategoryFilter) for backend in list(filter_backends): queryset = backend().filter_queryset(self.request, queryset, view=self) return queryset 方法4：get_serializer_class(self) 返回用于序列化的class。默认返回的是serializer_class属性设定的类。 在某些情况下，你可能要重写这个方法，用来适应动态的行为，比如可以为读 和 写 操作 设定不同的序列化器， 或者为 不同的用户 设定 不同的序列化器。 比如： def get_serializer_class(self): if self.request.user.is_staff: return FullAccountSerializer return BasicAccountSerializer 保存 和 删除 钩子： 下面的这些方法是由Mixins类提供，并提供了简单的用于覆盖对象默认的 保存和删除 的行为。 perform_create(self, serializer) —— 当保存一个新的对象实例的时候，通过CreateModelMixin来调用。 perform_update(self, serializer) —— 当保存一个已有的对象实例的时候，通过UpdateModelMixin来调用。 perform_destroy(self, instance) —— 当删除一个对象实例的时候，通过DestroyModelMixin来调用。 这些钩子对于设置请求中的隐藏属性，而这些属性又不是请求数据的一部分，是非常有用的。比如，你可能会基于请求的用户，或者基于URL的关键字参数来设置属性，比如下面这段代码： def perform_create(self, serializer): serializer.save(user=self.request.user) 这些可覆盖的点非常的多，用于在保存数据之前或者之后的各种行为。比如，在数据保存完之后可以发送确认邮件，或者日志更新等等。如下这段代码： def perform_update(self, serializer): instance = serializer.save() send_email_confirmation(user=self.request.user, modified=instance) 你还可以使用这些钩子来增加一些额外的验证，通过抛出ValidationError()异常。如果你需要在数据保存到数据库之前做一些逻辑性的验证操作，这可能是非常有用的。比如下面这段代码： def perform_create(self, serializer): queryset = SignupRequest.objects.filter(user=self.request.user) if queryset.exists(): raise ValidationError('You have already signed up') serializer.save(user=self.request.user) 注意： 这些方法取代了2.x版本中的pre_save, post_save, pre_delete和post_delete方法，它们将不再可用。 其他方法: 你不需要重写以下方法，如果你使用GenericAPIView在编写自定义的视图，里面可能会用到它们。 get_serializer_context(self) —— 返回一个字典包含任意的额外上下文，来提供给序列化器。默认包含'request', 'view'和'format'key。 get_serializer(self, instance=None, data=None, many=False, partial=False) —— 返回序列化器的实例。 get_paginated_response(self, data) —— 返回一个已经分页的Response对象。 paginate_queryset(self, queryset) —— 如果需要对queryset来进行分页，那么会返回一个分页对象，或者当没有给视图设置分页的时候返回一个None。 filter_queryset(self, queryset) —— 给定一个查询结果集，然后过滤器会处理该查询结果集，最后返回一个新的queryset查询结果集。 Mixins 类 源码位置： rest_framework.mixins.*Mixin Mixins类用来提供基本的视图行为动作。注意，Mixins类提供的是动作方法，而不是处理方法，比如提供了.create()和.list()而不是.post()和.get()。这样做，会允许更加灵活的组合。也就是说，GET请求的处理方法.get(), 可以包含多种动作方法，比如.create()和.list()方法。 这些mixins类，可以通过rest_framework.mixins来导入。 ListModelMixin 类 提供了.list(request, *args, **kwargs)方法，用于实现列出查询结果集。 如果查询结果集被填充，那么将返回一个200 OK的响应，response body是已经序列化的查询结果。当然这个响应的结果可能是已经分页的。 CreateModelMixin 类 提供了.create(request, *args, **kwargs)方法，用于实现创建并保存一个模型实例。 如果一个对象被创建，那么会返回一个201 Created的响应，response body是已经序列化的对象。如果包含一个名为url的key，那么response header的Location将会填充该值。 关于Location，点击此处。 如果用于创建对象的请求数据是无效的，那么会返回一个400 Bad Request的响应，response body是错误详情。 RetrieveModelMixin 类 提供了.retrieve(request, *args, **kwargs)方法，用来返回一个已经存在的模型实例。 如果对象可以被取出来，那么将返回一个200 OK的响应，response body是已经序列化的实例。否则的会返回404 Not Found。 UpdateModelMixin 类 提供一个.update(request, *args, **kwargs)方法，用于实现更新并保存一个已经存在的模型实例。 在这个类里面提供了.partial_update(request, *args, **kwargs)方法，同样是更新，只不过该方法用于局部更新，更新字段是可选的。这将允许PATCH的HTTP请求。 如果对象被更新，返回一个200 OK的响应，response body是已经序列化的实例。 如果用于更新对象的请求数据是无效的，那么会返回一个400 Bad Request, response body是错误详情。 DestroyModelMixin 类 提供一个.destroy(request, *args, **kwargs)方法， 用于实现删除一个已经存在的模型实例。 如果对象被删除，那么返回204 No Content，否则返回404 Not Found。 命名视图 类 源码位置： rest_framework.generics.*APIView 下面的类是具体的可以被直接使用的通用视图。如果你使用通用视图，那么下面的这些方法将足够你使用，除非你需要重写大量的行为。 这些类，可以从rest_framework.generics中导入。 CreateAPIView 类 用于create-onlyendpoints。 提供一个post处理方法。 包含CreateModelMixin和GenericAPIView 源代码： class CreateAPIView(mixins.CreateModelMixin, GenericAPIView): \"\"\" 创建一个模型实例的 具体的命名视图 \"\"\" def post(self, request, *args, **kwargs): return self.create(request, *args, **kwargs) ListAPIView 类 用于一个只读的端点，来代表一个模型实例的集合。(查询结果集) 提供一个get处理方法。 包含GenericAPIView, ListModelMixin RetrieveAPIView 类 用于一个只读的端点，来代表一个单个的模型实例。 提供一个get处理方法。 包含GenericAPIView, RetrieveModelMixin DestroyAPIView 类 用于删除一个单个的模型实例。 提供一个delete处理方法。 包含GenericAPIView, DestroyModelMixin UpdateAPIView 类 用于更新一个单个的模型实例。 提供put和patch处理方法。 包含GenericAPIView, UpdateModelMixin ListCreateAPIView 类 用于一个可读 可写的 端点，来代表一个模型实例的集合。 提供get和post处理方法。 包含GenericAPIView, ListModelMixin, CreateModelMixin 源代码： class ListCreateAPIView(mixins.ListModelMixin, mixins.CreateModelMixin, GenericAPIView): \"\"\" 具名通用视图， 用于列出一个查询结果集 或者 创建一个模型实例 \"\"\" def get(self, request, *args, **kwargs): return self.list(request, *args, **kwargs) def post(self, request, *args, **kwargs): return self.create(request, *args, **kwargs) RetrieveUpdateAPIView 类 用于可读 可更新 的端点， 来代表一个单个的模型实例。 提供get, put和patch处理方法。 包含GenericAPIView, RetrieveModelMixin, UpdateModelMixin RetrieveDestroyAPIView 类 用于可读 可删除 的端点， 来代表一个单个的模型实例。 提供get，delete处理方法。 包含GenericAPIView, RetrieveModelMixin, DestroyModelMixin RetrieveUpdateDestroyAPIView 类 用于 可读 可更新 可删除的端点， 来代表一个单个的模型实例。 提供get，delete, put和patch处理方法。 包含GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin 自定义 通用视图 通常你会使用已经存在的通用视图，只是会有一些自定义的行为。如果你发现你自己在多个地方重用了这些自定义的行为，你可能需要将这些行为重构到一个公共的类里面，然后就可以在任何的视图或者视图集合中来应用它。 创建自定义的 mixins 比如，你可能需要URL中的多个字段来查询对象，那么你可能需要创建一个Mixins类，比如下面这样： class MultipleFieldLookupMixin(object): \"\"\" 应用这个mixin 到任何的view 或者 viewset 中 来获得 多个字段的过滤， 基于 `lookup_fields`属性； 来代替默认的单个字段过滤。 \"\"\" def get_object(self): queryset = self.get_queryset() # Get the base queryset queryset = self.filter_queryset(queryset) # Apply any filter backends filter = {} for field in self.lookup_fields: if self.kwargs[field]: # Ignore empty fields. filter[field] = self.kwargs[field] obj = get_object_or_404(queryset, **filter) # Lookup the object self.check_object_permissions(self.request, obj) return obj 在任何时候，只要你需要，你都可以在任何视图或者视图集合中去使用它，比如这样： class RetrieveUserView(MultipleFieldLookupMixin, generics.RetrieveAPIView): queryset = User.objects.all() serializer_class = UserSerializer lookup_fields = ('account', 'username') 如果你需要自定义某些行为，那么使用Mixins是最好的选择。 创建自定义的 基础类 如果你使用了多个Mixins类，那么进一步，你可以自定义一个你自己的基础类，然后你可以在你的项目中使用它们。 比如下面这样： class BaseRetrieveView(MultipleFieldLookupMixin, generics.RetrieveAPIView): pass class BaseRetrieveUpdateDestroyView(MultipleFieldLookupMixin, generics.RetrieveUpdateDestroyAPIView): pass 如果在你的项目中，有大量的视图来处理各种行为，那么最好的办法是指定一个基础类。 PUT 用作 创建 数据 在REST framework的3.0版本之前，对于PUT可以是更新，也可以是创建操作； 这取决于对象是否存在。 允许PUT来当做创建操作是由问题的，因为这必然会暴露对象存在或者不存在的信息。 在3.0的版本中，不会再由PUT 用作 404 和 PUT 用作创建数据， 取而代之的是将404设为默认的行为，因为这更简单，更明了。 如果你需要使用通用的PUT-as-create， 你可以在Mixins中包含AllowPUTAsCreateMixin。点击此处查看代码。 第三方包 以下第三方包提供了额外的通用视图的实现。 Django REST Framework bulk 这个django-rest-framework-bulk package实现了一些通用视图和Mixins类以及一些具体的命名通用视图来实现通过API 请求实现批量操作。 Django Rest Multiple Models 这个Django Rest Multiple Models是了一些通用视图和Mixins视图，来实现通过一个单独的API请求来发送多个序列的模型实例集合或者是queryset(查询结果集)。 参考链接: https://docs.djangoproject.com/en/2.0/ref/class-based-views/#base-vs-generic-views https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Location https://github.com/miki725/django-rest-framework-bulk https://github.com/MattBroach/DjangoRestMultipleModels https://gist.github.com/tomchristie/a2ace4577eff2c603b1b "},"api/viewsets.html":{"url":"api/viewsets.html","title":"视图组Viewsets","keywords":"","body":"视图组Viewsets 路由器决定使用哪个控制器处理请求后，控制器负责解析请求，生成相应的输出。—— Ruby on Rails Documentation 点击此处查看文档。 Django REST framework允许您将一组相关视图的逻辑组合到一个名为ViewSet的类中。在其他框架中，您可能会发现概念上类似的实现，名为\"Resources\"或\"Controllers\"。 一个ViewSet类，只是一个简单的基于类的视图，它不提供任何处理方法，比如.get()或者.post()，而是提供了动作方法来代替，比如.list()和.create()。 一个ViewSet类，会使用.as_view()方法将处理方法和动作方法绑定。 相关的源代码位置在: rest_framework.viewsets.ViewSetMixin 通常，不是在urlconf中通过viewset来显示的注册你的视图，而是将viewset注册到router类中，这将会自动的为您确定需要的urlconf。 例子 让我们来定义一个简单的viewset， 主要目的是可以列出或者获取系统中的用户： from django.contrib.auth.models import User from django.shortcuts import get_object_or_404 from myapps.serializers import UserSerializer from rest_framework import viewsets from rest_framework.response import Response class UserViewSet(viewsets.ViewSet): \"\"\" A simple ViewSet for listing or retrieving users. \"\"\" def list(self, request): queryset = User.objects.all() serializer = UserSerializer(queryset, many=True) return Response(serializer.data) def retrieve(self, request, pk=None): queryset = User.objects.all() user = get_object_or_404(queryset, pk=pk) serializer = UserSerializer(user) return Response(serializer.data) 如果有必要，你可以绑定这个viewset到两个单独的视图里面，比如这样： user_list = UserViewSet.as_view({'get': 'list'}) user_detail = UserViewSet.as_view({'get': 'retrieve'}) 通常我们不会这样做，而是注册viewset到router里面，这将会自动生成urlconf： from myapp.views import UserViewSet from rest_framework.routers import DefaultRouter router = DefaultRouter() router.register(r'users', UserViewSet, base_name='user') urlpatterns = router.urls 如果你不是编写你自己的viewsets，而是你要使用一些现有的基类提供的一组默认功能，你完全可以这样做： class UserViewSet(viewsets.ModelViewSet): \"\"\" A viewset for viewing and editing user instances. \"\"\" serializer_class = UserSerializer queryset = User.objects.all() 使用ViewSet类相比使用View类，有两个主要的优点： 重复的逻辑可以合并到一个类中。在上面的例子中，我们只需要制定一次queryset，就可以在多个视图中使用了。 通过使用routers， 我们不再需要自己处理URL配置。 这两个都有一个这种。使用常规的视图和URL配置，会更加清晰明确，并且更容易控制。但是如果想要快速的运行，使用ViewSets； 或者您有大量的API并且希望始终有一致的URL配置，那么ViewSets就会很方便。 ViewSet 包含的动作 REST framework中默认的路由器将会为 create/retrieve/update/destroy 风格的动作提供一系列的路由，如下： class UserViewSet(viewsets.ViewSet): \"\"\" 这是一个viewset 的演示, 标准动作 将会 被 路由器处理. 如果你使用格式后缀, 请在每个动作中确保, 包含了`format=None`关键字参数. \"\"\" def list(self, request): pass def create(self, request): pass def retrieve(self, request, pk=None): pass def update(self, request, pk=None): pass def partial_update(self, request, pk=None): pass def destroy(self, request, pk=None): pass 在调度(dispatch)动作的期间，当前的动作可以通过.action属性获取。你可以通过检查.action来调整当前动作的行为。 比如，你可以在限制权限为处理list动作之外的其他： def get_permissions(self): \"\"\" Instantiates and returns the list of permissions that this view requires. \"\"\" if self.action == 'list': permission_classes = [IsAuthenticated] else: permission_classes = [IsAdmin] return [permission() for permission in permission_classes] 让额外的动作 使用路由 如果你又额外的方法需要被路由，那么你可以使用@detail_route或者@list_route装饰器，来标记这些方法可以被路由。 装饰器@detail_route在URL中匹配pk并且适用于只需要单个实例的方法。 装饰器@list_route适用于需要操作一组实例的方法。 比如： from django.contrib.auth.models import User from rest_framework import status from rest_framework import viewsets from rest_framework.decorators import detail_route, list_route from rest_framework.response import Response from myapp.serializers import UserSerializer, PasswordSerializer class UserViewSet(viewsets.ModelViewSet): \"\"\" A viewset that provides the standard actions \"\"\" queryset = User.objects.all() serializer_class = UserSerializer @detail_route(methods=['post']) def set_password(self, request, pk=None): user = self.get_object() serializer = PasswordSerializer(data=request.data) if serializer.is_valid(): user.set_password(serializer.data['password']) user.save() return Response({'status': 'password set'}) else: return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) @list_route() def recent_users(self, request): recent_users = User.objects.all().order('-last_login') page = self.paginate_queryset(recent_users) if page is not None: serializer = self.get_serializer(page, many=True) return self.get_paginated_response(serializer.data) serializer = self.get_serializer(recent_users, many=True) return Response(serializer.data) 这些装饰器还可以为仅仅路由到的视图上设置一些额外的参数。比如： @detail_route(methods=['post'], permission_classes=[IsAdminOrIsSelf]) def set_password(self, request, pk=None): ... 这些装饰器，默认情况下是路由GET请求，但是也可以设置接收其他HTTP方法，使用methods参数。比如： @detail_route(methods=['post', 'delete']) def unset_password(self, request, pk=None): ... 这两个新的动作将会在URL^users/{pk}/set_password/$和^users/{pk}/unset_password/$中可用。 解析URL中的动作 如果你需要获取一个带有动作的URL，使用.reverse_action()方法。这是对reverse()的一个便捷封装，它会自动传递视图的request对象，并且将url_name预先加入.basename属性。 关于reverser()的文档，点击查看。 注意：basename是在ViewSet注册到路由的时候提供的。如果你不使用router，那么你必须提供basename参数到.as_view()方法。 使用前一个小结的例子： >>> view.reverse_action('set-password', args=['1']) 'http://localhost:8000/api/users/1/set_password' 参数url_name应该和装饰器@list_route和@detail_route相匹配。另外，这也可以被用于reverse默认的list和detail路由。 API 参考 源码位置： rest_framework.viewsets ViewSet 类 类ViewSet是APIView的子类。所以你可以使用任何标准的属性，比如在你的ViewSet中使用permission_classes, authentication_classes来控制API策略。 类ViewSet中并没有提供任何动作的实现。所以你如果要使用ViewSet，你需要自己定义动作的实现。 REST framework 中的源代码如下： class ViewSet(ViewSetMixin, views.APIView): \"\"\" The base ViewSet class does not provide any actions by default. \"\"\" pass 在ViewSetMixin和APIView中都没有关于动作的实现。 GenericViewSet 类 类GenericViewSet是GenericAPIView的子类，并且提供了默认的get_object和get_queryset方法，和其他通用的视图行为，但是不包括其他任何默认的动作。 如果要使用GenericViewSet类，你需要重写需要的mixin类，或者显示的定义动作的实现。 REST framework中源码实现： class GenericViewSet(ViewSetMixin, generics.GenericAPIView): \"\"\" The GenericViewSet class does not provide any actions by default, but does include the base set of generic view behavior, such as the `get_object` and `get_queryset` methods. \"\"\" pass 父类ViewSetMixin和GenericAPIView没有任何动作的实现。 ModelViewSet 类 类ModelViewSet是GenericAPIView的子类，并且包含了多种多样的动作的实现，通过多种多样的mixins类来提供各种行为。 类ModelViewSet提供的动作包括.list(), .retrieve(), .create(), .update(), .partial_update()和.destroy()。 比如 因为ModelViewSet扩展了GenericAPIView，你至少要提供queryset和serializer_class属性。比如： class AccountViewSet(viewsets.ModelViewSet): \"\"\" A simple ViewSet for viewing and editing accounts. \"\"\" queryset = Account.objects.all() serializer_class = AccountSerializer permission_classes = [IsAccountAdminOrReadOnly] 注意，你可以使用GenericAPIView类提供的任何标准的属性和方法。比如，如果你要动态的确定查询结果集，你可能会这么做： class AccountViewSet(viewsets.ModelViewSet): \"\"\" A simple ViewSet for viewing and editing the accounts associated with the user. \"\"\" serializer_class = AccountSerializer permission_classes = [IsAccountAdminOrReadOnly] def get_queryset(self): return self.request.user.accounts.all() 注意，当从ViewSet中删除queryset属性之后，与之关联的router将无法自动获取你Model的base_name， 所以你必须在注册路由的时候要自己指定base_name。 提示： base_name是根据viewset中的queryset属性来得到当前操作的模型的名称(小写) 还要注意，尽管这个类默认提供了完整的create/list/retrieve/update/destroy操作集，但还可以通过使用标准权限类来限制可用操作。 ReadOnlyModelViewSet 类 类ReadOnlyModelViewSet类是GenericAPIView的之类，跟ModelViewSet类一样也包含多种动作的实现，但是不同的是，这里只包含只读的动作，.list()和.retrieve()。 例子 和ModelViewSet一样， 你至少要提供queryset和serializer_class属性。 比如 ： class AccountViewSet(viewsets.ReadOnlyModelViewSet): \"\"\" A simple ViewSet for viewing accounts. \"\"\" queryset = Account.objects.all() serializer_class = AccountSerializer 此外，同样的，你可以使用GenericAPIView提供的标准的属性和方法。 自定义ViewSet 基础类 你可能需要提供自定义的ViewSet类，并不像ModelViewSet类一样包含所有的动作， 或者自定义一些行为。 例子 创建一个基础的viewset类，来提供create，list和retrieve操作，继承GenericViewSet，并混合需要的动作： from rest_framework import mixins class CreateListRetrieveViewSet(mixins.CreateModelMixin, mixins.ListModelMixin, mixins.RetrieveModelMixin, viewsets.GenericViewSet): \"\"\" A viewset that provides `retrieve`, `create`, and `list` actions. To use it, override the class and set the `.queryset` and `.serializer_class` attributes. \"\"\" pass 通过创建你自己的基础的ViewSet类，你可以提供常见的行为，然后在你的API中重用他们。 参考链接： http://guides.rubyonrails.org/action_controller_overview.html https://docs.djangoproject.com/en/2.0/ref/urlresolvers/ "},"api/routers.html":{"url":"api/routers.html","title":"路由器Routers","keywords":"","body":"路由器Routers 资源路由（resource routing）允许我们为资源式控制器快速声明所有常见路由。只需一行代码即可完成资源路由的声明，无需为 index、show、new、edit、create、update 和 destroy 动作分别声明路由。—— Ruby on Rails文档 点击此处, 查看文档 一些Web框架比如Rails提供了自动确定应该如何为应用程序的URLs映射到逻辑处理功能来处理传入的请求。 REST framework为Django增加了自动路由的功能，并且为你提供了一个简单的、快速的和一致的方式来根据你的视图逻辑设置一组URLs。 用法 这是一个简单的URL配置，使用了SimpleRouter类： from rest_framework import routers router = routers.SimpleRouter() router.register(r'users', UserViewSet) router.register(r'accounts', AccountViewSet) urlpatterns = router.urls 方法register()必须接受两个参数： prefix： 这组路由的URL前缀。 viewset： 对应的viewset类。 当然，你还可以指定一个额外的可选参数： base_name： 基于这个来确定创建的URL的名称。如果没有设置该参数，那么会自动的根据viewset中的queryset属性自动生成。如果viewset中没有定义queryset属性，那么在注册路由的时候必须指定该属性。 源码位置: rest_framework.routers.SimpleRouter： def get_default_base_name(self, viewset): \"\"\" If `base_name` is not specified, attempt to automatically determine it from the viewset. \"\"\" queryset = getattr(viewset, 'queryset', None) assert queryset is not None, '`base_name` argument not specified, and could ' \\ 'not automatically determine the name from the viewset, as ' \\ 'it does not have a `.queryset` attribute.' return queryset.model._meta.object_name.lower() 提示： base_name是根据viewset中的queryset属性来得到当前操作的模型的名称(小写) 提示： base_name最后会自动生成name={basename}-list，name={basename}-detail和name='{basename}-{methodnamehyphen}'。 上面的示例将产生以下的URL模式： URL pattern： ^users/$ 名称： 'user-list' URL pattern: ^users/{pk}/$ 名称： 'user-detail' URL pattern: ^accounts/$ 名称： 'account-list' URL pattern: ^accounts/{pk}/$ 名称： 'account-detail' 注意： base_name参数被用来指定view name pattern初始化的一部分。 在上面的例子中， user或者account就代表这一部分。 通常来说我们不需要指定base_name参数。但是，如果你再viewset中自定义了get_queryset方法，那么viewset将不会再由.queryset属性。 此时， 如果你尝试去注册你的viewset，那么会得到如下错误： 'base_name' argument not specified, and could not automatically determine the name from the viewset, as it does not have a '.queryset' attribute. 这个错误的意思是，当不能自动确定你的模型的名称的时候，当你注册viewset的时候，你需要显示的指定base_name参数。 在Django的根URL中 包含 REST framework URLs 对于router的实例的.urls属性是一个简单的、标准的列表, 元素是URL patterns。所以说，就可以有多种风格将这些路由添加到你的Django根路由。 比如，你可以添加router.urls到现有的list： router = routers.SimpleRouter() router.register(r'users', UserViewSet) router.register(r'accounts', AccountViewSet) urlpatterns = [ url(r'^forgot-password/$', ForgotPasswordFormView.as_view()), ] urlpatterns += router.urls 或者，你还可以使用Django的include函数， 比如： urlpatterns = [ url(r'^forgot-password/$', ForgotPasswordFormView.as_view()), url(r'^', include(router.urls)), ] 当然也可以指定命名空间： urlpatterns = [ url(r'^forgot-password/$', ForgotPasswordFormView.as_view()), url(r'^api/', include(router.urls, namespace='api')), ] 如果你使用了hyperlinked serializers和 url 命名空间 ，那么你需要确定serializers中的view_name正确的反应了你的命名空间。 在上面的例子中，你需要在你的序列化user detail视图的超链接字段中指定参数view_name='api:user-detail'。 class UserSerializer(serializers.HyperlinkedModelSerializer): # 如果在project/urls.py中引用API的话就不需要设定, 直接使用 view_name=\"model-detail\" # 如果在project/urls.py中定义了app01/urls.py的namespace为app01，那么这里就必须定义，而且必须是view_name=\"app01:model-detail\"这种格式 url = serializers.HyperlinkedIdentityField(view_name=\"user-detail\") 设置额外的 链接地址 和 动作 在viewset中的任何方法，只要加上装饰器@detail_route或者是@list_route之后，就会被路由。比如，在UserViewSet中给定一个方法： from myapp.permissions import IsAdminOrIsSelf from rest_framework.decorators import detail_route class UserViewSet(ModelViewSet): ... @detail_route(methods=['post'], permission_classes=[IsAdminOrIsSelf]) def set_password(self, request, pk=None): ... 以下URL pattern将会生成: URL pattern: ^users/{pk}/set_password/$ Name： 'user-set-password' 如果你不想为你的自定义的动作使用默认的规则生成URL， 你可以使用url_path参数定制URL，来代替它。 比如，你想要改变我们自定义的动作的URL 为 ^users/{pk}/change-password/$， 你可以这样做： from myapp.permissions import IsAdminOrIsSelf from rest_framework.decorators import detail_route class UserViewSet(ModelViewSet): ... @detail_route(methods=['post'], permission_classes=[IsAdminOrIsSelf], url_path='change-password') def set_password(self, request, pk=None): ... 上面的示例，将会生成如下的URL pattern： URL pattern: ^users/{pk}/change-password/$ Name： 'user-change-password' 如果，你想要改变你自定义动作的默认的 名字， 你可以使用url_name参数来定制它。 比如， 如果你想要为你的自定义动作，改变名称为 'user-change-password'， 你可以这样： from myapp.permissions import IsAdminOrIsSelf from rest_framework.decorators import detail_route class UserViewSet(ModelViewSet): ... @detail_route(methods=['post'], permission_classes=[IsAdminOrIsSelf], url_name='change-password') def set_password(self, request, pk=None): ... 上面的示例，将会生成如下的URL pattern： URL pattern： ^users/{pk}/set_password/$ Name： 'user-change-password' 当然你还可以同时使用url_path和url_name参数来生成URL。 关于ViewSet的文档，点击这里查看。 API 指南 SimpleRouter类 这个路由实例包含了标准的list, create, retrieve, update, partial_update和destroy路由动作。在viewset中使用@detail_route和@list_route装饰器的额外的方法也可以被路由。 URL 风格HTTP 方法动作URL 名称 {prefix}/GETlist{basename}-list POSTcreate {prefix}/{methodname}/GET, 或者通过方法的参数指定使用`@list_route`装饰器的函数{basename}-{methodname} {prefix}/{lookup}/GETretrieve{basename}-detail PUTupdate PATCHpartial_update DELETEdestroy {prefix}/{lookup}/{methodname}/GET, 或者通过方法的参数指定使用`@detail_route`装饰器的函数{basename}-{methodname} 默认情况下，使用SimpleRouter创建的URL的末尾都会追加一个/， 可以通过在初始化路由实例的时候，指定参数trailing_slash为False可以修改这个行为，比如： router = SimpleRouter(trailing_slash=False) \b在URL的末尾带有/是Django的常规的行为，但是这种行为在其他的框架中并没有。选择使用哪种风格的URL在很大程度上是一个偏好问题，尽管一些JavaScript框架可能会期望特定的路由风格。 路由器会通过匹配任何除了/和.的字符来进行查找。如果要设置更加宽松或者更加严格的匹配规则，可以在viewset中设置lookup_value_regex属性。比如，比如你可以将查找设置为有效的UUIDs： class MyModelViewSet(mixins.RetrieveModelMixin, viewsets.GenericViewSet): lookup_field = 'my_model_id' lookup_value_regex = '[0-9a-f]{32}' DefaultRouter类 这个路由器，跟上面的SimpleRouter基本上是一样的。但是这个路由器额外的包含了一个默认的API根视图，这个视图会返回一个包含所有的list view的超链接。它还可以为可选的后缀为.json的风格生成路由。 URL 风格HTTP 方法动作URL 名称 [.format]GET自动生成的根视图api-root {prefix}/[.format]GETlist{basename}-list POSTcreate {prefix}/{methodname}/[.format]GET, 或者通过方法的参数指定使用`@list_route`装饰器的函数{basename}-{methodname} {prefix}/{lookup}/[.format]GETretrieve{basename}-detail PUTupdate PATCHpartial_update DELETEdestroy {prefix}/{lookup}/{methodname}/[.format]GET, 或者通过方法的参数指定使用`@detail_route`装饰器的函数{basename}-{methodname} 和SimpleRouter一样，会在URL末尾追加/， 然后可以通过初始化路由器的时候，修改参数来改变： router = DefaultRouter(trailing_slash=False) 自定义路由 实现自定义的路由，并不是经常要做的事情，但是如果你对API的URL结构有特殊的需求，那么这块就会非常的有用。这样，你就可以将URL以可重用的方式封装，以确保不会显式的编写URL pattern。 最简答的实现自定义路由的方式是，以现有的路由器类来自定义一个路由器之类。.routes属性是用来映射URL pattern和每个viewset视图的模板。.routes属性是个包含`Router命名元组的列表。 这个Route命名元组的参数解释如下： url：一个字符串，表示要路由的URL。可能包含以下几个格式化字符串： {prefix}: 这组路由使用的URL前缀 {lookup}: 用于匹配单个实例的查找字段 {trailing_slash}: 可能为/或者是空字符串，依赖于trailing_slash参数 mapping: HTTP方法名称和view方法的映射关系 name: 可以被Django中的reverse来调用的\b\bURL的名称。可能包含以下格式化字符串： {basename}: URL名字是基于这个来创建的。 具体参考viewset中设置basename initkwargs: 在实例化视图时应该传递的任何附加参数的字典。注意，.suffix参数保留用于标识viewset的类型，用于生成视图名称和面包屑导航。 源码位置： rest_framework.routers.SimpleRouter class SimpleRouter(BaseRouter): routes = [ # List route. Route( url=r'^{prefix}{trailing_slash}$', mapping={ 'get': 'list', 'post': 'create' }, name='{basename}-list', initkwargs={'suffix': 'List'} ), # Dynamically generated list routes. # Generated using @list_route decorator # on methods of the viewset. DynamicListRoute( url=r'^{prefix}/{methodname}{trailing_slash}$', name='{basename}-{methodnamehyphen}', initkwargs={} ), # Detail route. Route( url=r'^{prefix}/{lookup}{trailing_slash}$', mapping={ 'get': 'retrieve', 'put': 'update', 'patch': 'partial_update', 'delete': 'destroy' }, name='{basename}-detail', initkwargs={'suffix': 'Instance'} ), # Dynamically generated detail routes. # Generated using @detail_route decorator on methods of the viewset. DynamicDetailRoute( url=r'^{prefix}/{lookup}/{methodname}{trailing_slash}$', name='{basename}-{methodnamehyphen}', initkwargs={} ), ] def __init__(self, trailing_slash=True): self.trailing_slash = trailing_slash and '/' or '' super(SimpleRouter, self).__init__() ……省略…… 自定义动态路由 当然你还可以自定义@list_route和@detail_route装饰器应该被如何路由。它们都包含在.routes列表的DynamicListRoute和DynamicDetailRoute的命名元组中。 参数解释如下： url: 表示被路由的URL字符串。 name: 可以被Django中的reverse来调用的\b\bURL的名称。 initkwargs: 在实例化视图时应该传递的任何附加参数的字典。 源代码，看上一小节。 案例 在下面的例子中我们将仅仅会路由list和retrieve动作，并且不会遵循Django的/惯例： from rest_framework.routers import Route, DynamicDetailRoute, SimpleRouter class CustomReadOnlyRouter(SimpleRouter): \"\"\" A router for read-only APIs, which doesn't use trailing slashes. \"\"\" routes = [ Route( url=r'^{prefix}$', mapping={'get': 'list'}, name='{basename}-list', initkwargs={'suffix': 'List'} ), Route( url=r'^{prefix}/{lookup}$', mapping={'get': 'retrieve'}, name='{basename}-detail', initkwargs={'suffix': 'Detail'} ), DynamicDetailRoute( url=r'^{prefix}/{lookup}/{methodnamehyphen}$', name='{basename}-{methodnamehyphen}', initkwargs={} ) ] 接下来，让我们看看，我们的CustomReadOnlyRouter将会为我们简单的viewset生成怎么样的路由。 首先在view.py中，代码如下： class UserViewSet(viewsets.ReadOnlyModelViewSet): \"\"\" viewset 默认提供了标准的动作, 这里我们只定义额外的动作 \"\"\" queryset = User.objects.all() serializer_class = UserSerializer lookup_field = 'username' @detail_route() def group_names(self, request, pk=None): \"\"\" 返回属于给定用户的所有组的名字的列表. \"\"\" user = self.get_object() groups = user.groups.all() return Response([group.name for group in groups]) 在urls.py中，代码如下： router = CustomReadOnlyRouter() router.register('users', UserViewSet) urlpatterns = router.urls 最后，会生成如下的映射关系： URL HTTP 方法 动作 URL 名称 /users GET list user-list /users/{username} GET retrieve user-detail /users/{username}/group-names GET group_names user-group-names 更多的其他属性的设置，查看SimpleRouter源代码。 更加高级自定义路由 如果你想要提供一个完整的自定义的行为，你可以继承BaseRouter类，并且要重写get_urls(self)方法。这个方法应该检查注册的viewset并返回一个URL pattern列表。可以通过访问self.registry来检查注册的prefix(前缀), viewsets(视图集) 和 basename。 你可能想要覆盖get_default_base_name(self, viewset)方法，或者在向路由器注册的ViewSet中始终显式的设置base_name参数。 源代码位置: rest_framework.routers.SimpleRouter class BaseRouter(object): def __init__(self): self.registry = [] def register(self, prefix, viewset, base_name=None): if base_name is None: base_name = self.get_default_base_name(viewset) self.registry.append((prefix, viewset, base_name)) ……省略…… class SimpleRouter(BaseRouter): ……省略…… def get_default_base_name(self, viewset): \"\"\" 如果 `base_name` 没有指定, 就会尝试自动去确定它, 从viewset中. \"\"\" queryset = getattr(viewset, 'queryset', None) assert queryset is not None, '`base_name` argument not specified, and could ' \\ 'not automatically determine the name from the viewset, as ' \\ 'it does not have a `.queryset` attribute.' return queryset.model._meta.object_name.lower() ……省略…… def get_urls(self): \"\"\" 使用已经注册的 viewsets 来生成 URL patterns 列表. \"\"\" ret = [] for prefix, viewset, basename in self.registry: lookup = self.get_lookup_regex(viewset) routes = self.get_routes(viewset) for route in routes: # Only actions which actually exist on the viewset will be bound mapping = self.get_method_map(viewset, route.mapping) if not mapping: continue # Build the url pattern regex = route.url.format( prefix=prefix, lookup=lookup, trailing_slash=self.trailing_slash ) # If there is no prefix, the first part of the url is probably # controlled by project's urls.py and the router is in an app, # so a slash in the beginning will (A) cause Django to give # warnings and (B) generate URLS that will require using '//'. if not prefix and regex[:2] == '^/': regex = '^' + regex[2:] initkwargs = route.initkwargs.copy() initkwargs.update({ 'basename': basename, }) view = viewset.as_view(mapping, **initkwargs) name = route.name.format(basename=basename) ret.append(url(regex, view, name=name)) ## 看这里的最后的结果就是Django的URL pattern return ret 第三方包 以下第三方包也可以用。 DRF Nested Routers 第三方包drf-nested-routers package 用于处理嵌套资源的 路由 和 关系字段。 ModelRouter(wq.db.rest) 第三方包wq.db package提供了一个高级的ModelRouter类。 DRF-extensions 第三方包DRF-extensions包提供用于创建嵌套视图集的路由器，具有可定制端点名称的集合级控制器。 参考链接： http://edgeguides.rubyonrails.org/routing.html https://github.com/alanjds/drf-nested-routers https://wq.io/1.0/docs/router https://chibisov.github.io/drf-extensions/docs/#nested-routes https://chibisov.github.io/drf-extensions/docs/#collection-level-controllers https://chibisov.github.io/drf-extensions/docs/#controller-endpoint-name "},"api/parsers.html":{"url":"api/parsers.html","title":"解析器Parsers","keywords":"","body":"解析器Parsers 机器交互式Web服务更倾向于使用更多的结构化格式来发送数据，而不是简单的表单格式。这是因为他们会发送比表单更复杂的数据。—— Malcom Tredinnick REST framework包含了许多内置的解析器类，允许您使用各种Media Types来接收请求。当然，也可以支持定义你自己的解析器，这使得你可以灵活的设计你的API所接收的Media Types。 解析器是如何确定的 视图中有效的解析器总是被定义为一个包含类的列表。当request.data中的数据被访问的时候，REST framework将会检查传进来的请求中的HTTP 头中的Content-Type来确定使用哪种解析器来解析请求数据(request data)。 注意： 在开发HTTP 客户端应用程序的时候，应该始终记住在请求中设置Content-Type头。 如果你不设置content type，大多数客户端默认将会使用'application/x-www-form-urlencoded'， 这可能不是你想要的。 举个例子，如果你要用JQuery的.ajax()方法发送一个使用JSON编码的数据，那么你应该始终设置contentType: 'application/json'。 设置解析器 默认情况下解析器的设置可能是通过DEFAULT_PARSER_CLASSES设置的全局的。比如，下面的设置将仅仅允许JSON的请求，代替了默认的JSON or form data的设置。 REST_FRAMEWORK = { 'DEFAULT_PARSER_CLASSES': ( 'rest_framework.parsers.JSONParser', ) } 你还可以为基于APIView的单个视图或者视图集合(viewset)设置解析器： from rest_framework.parsers import JSONParser from rest_framework.response import Response from rest_framework.views import APIView class ExampleView(APIView): \"\"\" A view that can accept POST requests with JSON content. \"\"\" parser_classes = (JSONParser,) def post(self, request, format=None): return Response({'received data': request.data}) 或者为基于@api_view装饰器的函数视图设置解析器： from rest_framework.decorators import api_view from rest_framework.decorators import parser_classes from rest_framework.parsers import JSONParser @api_view(['POST']) @parser_classes((JSONParser,)) def example_view(request, format=None): \"\"\" A view that can accept POST requests with JSON content. \"\"\" return Response({'received data': request.data}) API 参考 关于解析器的源码位置： rest_framework.parsers JSONParser解析器 解析请求内容是JSON格式的数据 HTTP请求中的.media_type为 application/json FormParser解析器 解析请求内容是HTML表单的数据。request.data的内容将被QueryDict填充。 源代码： class FormParser(BaseParser): \"\"\" Parser for form data. \"\"\" media_type = 'application/x-www-form-urlencoded' def parse(self, stream, media_type=None, parser_context=None): \"\"\" Parses the incoming bytestream as a URL encoded form, and returns the resulting QueryDict. \"\"\" parser_context = parser_context or {} encoding = parser_context.get('encoding', settings.DEFAULT_CHARSET) data = QueryDict(stream.read(), encoding=encoding) ### 注意这里返回的 QueryDict return data 通常情况下，会将FormParser和MultiPartParser来一起使用，以便完美的支持HTML表单数据。 HTTP请求中的.media_type为 application/x-www-form-urlencoded MultiPartParser解析器 解析支持文件上传的多部分HTML表单内容。 通常情况下，会将FormParser和MultiPartParser来一起使用，以便完美的支持HTML表单数据。 HTTP请求中的.media_type为 multipart/form-data FileUploadParser解析器 解析原始文件上传的内容。request.data的属性将是一个包含上传文件的单个关键字'file'的字典。 相关源代码： class FileUploadParser(BaseParser): \"\"\" Parser for file upload data. \"\"\" media_type = '*/*' errors = { 'unhandled': 'FileUpload parse error - none of upload handlers can handle the stream', 'no_filename': 'Missing filename. Request should include a Content-Disposition header with a filename parameter.', } def parse(self, stream, media_type=None, parser_context=None): \"\"\" Treats the incoming bytestream as a raw file upload and returns a `DataAndFiles` object. `.data` will be None (we expect request body to be a file content). `.files` will be a `QueryDict` containing one 'file' element. \"\"\" parser_context = parser_context or {} request = parser_context['request'] encoding = parser_context.get('encoding', settings.DEFAULT_CHARSET) meta = request.META upload_handlers = request.upload_handlers filename = self.get_filename(stream, media_type, parser_context) if not filename: raise ParseError(self.errors['no_filename']) # Note that this code is extracted from Django's handling of # file uploads in MultiPartParser. content_type = meta.get('HTTP_CONTENT_TYPE', meta.get('CONTENT_TYPE', '')) try: content_length = int(meta.get('HTTP_CONTENT_LENGTH', meta.get('CONTENT_LENGTH', 0))) except (ValueError, TypeError): content_length = None # See if the handler will want to take care of the parsing. for handler in upload_handlers: result = handler.handle_raw_input(stream, meta, content_length, None, encoding) if result is not None: return DataAndFiles({}, {'file': result[1]}) ### 看这里返回的字典 # This is the standard case. possible_sizes = [x.chunk_size for x in upload_handlers if x.chunk_size] chunk_size = min([2 ** 31 - 4] + possible_sizes) chunks = ChunkIter(stream, chunk_size) counters = [0] * len(upload_handlers) for index, handler in enumerate(upload_handlers): try: handler.new_file(None, filename, content_type, content_length, encoding) except StopFutureHandlers: upload_handlers = upload_handlers[:index + 1] break for chunk in chunks: for index, handler in enumerate(upload_handlers): chunk_length = len(chunk) chunk = handler.receive_data_chunk(chunk, counters[index]) counters[index] += chunk_length if chunk is None: break for index, handler in enumerate(upload_handlers): file_obj = handler.file_complete(counters[index]) if file_obj is not None: return DataAndFiles({}, {'file': file_obj}) ### 看这里返回的字典 raise ParseError(self.errors['unhandled']) 如果在URL关键字参数中有filename，调用了相关的视图，视图调用了FileUploadParser解析器，那么这个关键字参数将会用作文件名。 如果并没有URL关键字参数，那么客户端必须在HTTP头中设置文件名。比如这样： Content-Disposition: attachment; filename=upload.jpg。 HTTP请求中的.media_type为 */* 注意： 解析器FileUploadParser应该用于本地的客户端上传原始的数据的请求。如果是基于Web端的上传文件，或者是为本地客户端支持multipart upload，那么解析器应该用MultiPartParser。 由于FileUploadParser可以匹配任何类型的Media类型，所以通常这个解析器可以设置在APIView上。 解析器FileUploadParser使用的是Django的request.upload_handlers。 基本使用案例： # views.py class FileUploadView(views.APIView): parser_classes = (FileUploadParser,) def put(self, request, filename, format=None): file_obj = request.data['file'] # ... # do some stuff with uploaded file # ... return Response(status=204) # urls.py urlpatterns = [ # ... url(r'^upload/(?P[^/]+)$', FileUploadView.as_view()) ] 自定义 解析器 要想实现自定义的解析器，你应该继承BaseParser类，并且要设置.media_type属性，还要实现.parse(self, stream, media_type, parser_context)方法。 这个方法返回的数据，被填充在request.data中。 应该给.parser()方法中传递的参数有： stream: 一个表示request body的流式对象。 media_type: 可选的，如果设置了，那么就代表进入请求的内容的Media类型。依赖HTTP请求头中的Content-Type:。 parser_context: 可选的。如果提供，这个参数将是一个字典，其中包含可能需要分析请求内容的任何附加上下文。默认包含以下key， view, request, args和kwargs。 Example 下面是一个普通文本解析器的一个实例，最后会将文本的内容字符串作为数据填充到request.data中： class PlainTextParser(BaseParser): \"\"\" Plain text parser. \"\"\" media_type = 'text/plain' def parse(self, stream, media_type=None, parser_context=None): \"\"\" Simply return a string representing the body of the request. \"\"\" return stream.read() 第三方包 下面是一些可用的第三方包。 YAML REST framework YAML提供了YAML的解析和渲染支持。之前在REST framework有YAML的支持，现在使用第三方的包来替代。 使用pip安装： $ pip install djangorestframework-yaml 修改你的REST framework的设置： REST_FRAMEWORK = { 'DEFAULT_PARSER_CLASSES': ( 'rest_framework_yaml.parsers.YAMLParser', ), 'DEFAULT_RENDERER_CLASSES': ( 'rest_framework_yaml.renderers.YAMLRenderer', ), } XML REST Framework XML提供了一个简单的非正式的XML格式。 使用pip安装： $ pip install djangorestframework-xml 修改REST framework的设置： REST_FRAMEWORK = { 'DEFAULT_PARSER_CLASSES': ( 'rest_framework_xml.parsers.XMLParser', ), 'DEFAULT_RENDERER_CLASSES': ( 'rest_framework_xml.renderers.XMLRenderer', ), } MessagePack MessagePack 是一个快速的、高效的 二进制序列化格式。 djangorestframework-msgpack包为REST framework提供了MessagePack的渲染器和解析器。 驼峰 JSON djangorestframework-camel-case包为REST framework提供了驼峰JSON的渲染器和解析器。这意味着你可以在序列化程序中使用Python风格的下划线语法，而最后导出的时候使用JavaScript风格的驼峰语法。 参考链接： https://jpadilla.github.io/django-rest-framework-yaml/ https://jpadilla.github.io/django-rest-framework-xml/ https://github.com/juanriaza/django-rest-framework-msgpack https://github.com/vbabiy/djangorestframework-camel-case "},"api/renderers.html":{"url":"api/renderers.html","title":"渲染器Renderers","keywords":"","body":"渲染Renderers 在TemplateResponse 实例返回给客户端之前，它必须被渲染。渲染的过程采用模板和上下文变量的中间表示形式，并最终将它转换为可以发送给客户端的字节流。—— Django官方文档(TemplateResponse and SimpleTemplateResponse) 点击此处，查看官方文档 REST framework包含很多的内置渲染器类。允许你使用各种各样的媒体类型返回响应。还可以设置自定义的渲染器类，来灵活的设计你自己的媒体类型。 渲染器是如何确定的 视图中有效的渲染器总是被设置为一个包含类的列表。当进入一个View逻辑的时候，REST framework会对传进来的请求执行内容协商，并且最终会确定一个最合适的渲染器，以满足Request。 内容协商的最基本的过程是检查HTTP请求头的Accept，用来确定哪种Media类型是响应最期望的。可选的，URL的格式后缀被用于显示请求特定的表示。比如，URLhttp://example.com/api/users_count.json可能只会返回JSON数据。 更多信息查看内容协商文档 设置渲染器 默认情况下渲染器的设置可能是通过DEFAULT_RENDERER_CLASSES设置的全局的。比如，下面的设置将会使用JSON作为主要的媒体类型并且还包括可HTML浏览API。 REST_FRAMEWORK = { 'DEFAULT_RENDERER_CLASSES': ( 'rest_framework.renderers.JSONRenderer', 'rest_framework.renderers.BrowsableAPIRenderer', ) } 你还可以为基于APIView的单个视图或者视图集合(viewset)设置渲染器： from django.contrib.auth.models import User from rest_framework.renderers import JSONRenderer from rest_framework.response import Response from rest_framework.views import APIView class UserCountView(APIView): \"\"\" A view that returns the count of active users in JSON. \"\"\" renderer_classes = (JSONRenderer, ) def get(self, request, format=None): user_count = User.objects.filter(active=True).count() content = {'user_count': user_count} return Response(content) 或者为基于@api_view装饰器的函数视图设置渲染器： @api_view(['GET']) @renderer_classes((JSONRenderer,)) def user_count_view(request, format=None): \"\"\" A view that returns the count of active users in JSON. \"\"\" user_count = User.objects.filter(active=True).count() content = {'user_count': user_count} return Response(content) 渲染器类的排序 当为您的API指定渲染器类的时候，要考虑你想要分配给每种Media类型的优先级，这一点非常重要。当客户端没有指定一个可以接受的表现形式，比如发送一个Accept: */*HTTP请求头，或者在请求头中不包括任何Accept，那么REST framework将会选择列表中的第一个渲染器来用于响应数据。 比如你的API服务器支持JSON的响应和HTML可浏览的API，你可能想要指定JSONRenderer为你默认的渲染器，这样那些没有指定AcceptHTTP头的客户端将会接收到JSON响应。 如果你的API服务器，包含可以根据请求来确定提供常规网页和API响应的视图，你可能会考虑设置TemplateHTMLRenderer作为你的默认的渲染器。 API 参考 关于渲染器的源码位置： rest_framework.renderers JSONRenderer渲染器 使用UTF-8编码，将请求数据渲染为JSON。 注意，默认情况下包含Unicode字符串，并且用紧凑的格式来呈现，没有多余的空白符： {\"unicode black star\":\"★\",\"value\":999} 客户端可能会包含额外的Media类型参数indent，这表示返回的JSON数据会被缩进。比如Accept: application/json; indent=4： { \"unicode black star\": \"★\", \"value\": 999 } 默认的编码风格使用UNICODE_JSON和COMPACT_JSON设置来修改。 在rest_framework.settings.DEFAULTS 中有如下设置： DEFAULTS = { ……省略…… # Encoding 'UNICODE_JSON': True, 'COMPACT_JSON': True, 'STRICT_JSON': True, 'COERCE_DECIMAL_TO_STRING': True, 'UPLOADED_FILES_USE_URL': True, # Browseable API 'HTML_SELECT_CUTOFF': 1000, 'HTML_SELECT_CUTOFF_TEXT': \"More than {count} items...\", ……省略…… } .media_type为 application/json URL .format后缀为： '.json' .charset: None TemplateHTMLRenderer渲染器 使用Django标准的模板渲染将数据渲染到HTML中。不像其他渲染器，数据被传递给Response不需要序列化。另外，与其他渲染器不同，在创建Response的时候你需要包含template_name参数。 渲染器TemplateHTMLRenderer将会创建一个RequestContext， 使用response.data作为内容，并且确定一个模板名称用于渲染一个内容。 模板名称是按照下面的顺序来确定的： 显式的传递给Response对象一个template_name参数。 在类里面明确的设置.template_name属性。 返回view.get_template_names()的结果。 下面是一个使用TemplateHTMLRenderer渲染器的示例： class UserDetail(generics.RetrieveAPIView): \"\"\" A view that returns a templated HTML representation of a given user. \"\"\" queryset = User.objects.all() renderer_classes = (TemplateHTMLRenderer,) def get(self, request, *args, **kwargs): self.object = self.get_object() return Response({'user': self.object}, template_name='user_detail.html') 如果你要使用TemplateHTMLRenderer，你可以使用REST framework返回一个常规的HTML 页面，或者从一个单一的Endpoint同时返回HTML和API响应数据。 如果你使用TemplateHTMLRenderer和其他的渲染器来构建你的Web站点，你应该考虑将TemplateHTMLRenderer放在renderer_classes列表的第一个，这样即使客户端的HTTP Request Header中的ACCEPT不正确，它也会优先使用TemplateHTMLRenderer。 参考链接，HTML & Forms Topic Page来查看更多的案例使用。 .media_type为 text/html URL .format后缀为： '.html' .charset: utf-8 StaticHTMLRenderer渲染器 一个简单的渲染器，它会返回一个预渲染的HTML。不像其他的渲染器，传递给Response对象的数据应该是一个表示要返回的字符串。 下面是一个使用StaticHTMLRenderer的例子： @api_view(('GET',)) @renderer_classes((StaticHTMLRenderer,)) def simple_html_view(request): data = 'Hello, world' return Response(data) 如果你要使用StaticHTMLRenderer，你可以使用REST framework返回一个常规的HTML 页面，或者从一个单一的Endpoint同时返回HTML和API响应数据。 .media_type为 text/html URL .format后缀为： '.html' .charset: utf-8 注意： StaticHTMLRenderer渲染器类是TemplateHTMLRenderer渲染器类的子类。 BrowsableAPIRenderer渲染器 为可视化的API将数据渲染到HTML中。 该渲染器，会确定哪个渲染器具有最高的级别，然后使用它在HTML页面中显示API的响应样式。 AdminRenderer渲染器 HTMLFormRenderer渲染器 MultiPartRenderer渲染器 自定义渲染器 例子 设置字符集 高级渲染器用法 通过媒体类型改变行为 Underspecifying the media type 设计你的媒体类型 HTML 错误视图 第三方包 YAML XML JSONP MessagePack CSV UltraJSON 驼峰JSON Pandas (CSV, Excel, PNG) LaTeX 参考链接： https://docs.djangoproject.com/en/2.0/ref/template-response/ "},"api/serializers.html":{"url":"api/serializers.html","title":"序列化","keywords":"","body":"序列化 "},"api/serializersfield.html":{"url":"api/serializersfield.html","title":"Serializer fields","keywords":"","body":"Serializer fields "},"api/serializersrelat.html":{"url":"api/serializersrelat.html","title":"Serializer relations","keywords":"","body":"Serializer relations "},"api/validators.html":{"url":"api/validators.html","title":"校验器Validators","keywords":"","body":"校验器Validators "},"api/authentication.html":{"url":"api/authentication.html","title":"身份验证","keywords":"","body":"身份验证 "},"api/permissions.html":{"url":"api/permissions.html","title":"权限","keywords":"","body":"权限 "},"api/throttling.html":{"url":"api/throttling.html","title":"限流Throttling","keywords":"","body":"Throttling "},"api/filtering.html":{"url":"api/filtering.html","title":"过滤","keywords":"","body":"过滤 "},"api/pagination.html":{"url":"api/pagination.html","title":"分页","keywords":"","body":"分页 "},"api/versioning.html":{"url":"api/versioning.html","title":"API 版本化","keywords":"","body":"API 版本化 "},"api/cnegotiation.html":{"url":"api/cnegotiation.html","title":"内容协商Content negotiation","keywords":"","body":"Content negotiation "},"api/metadata.html":{"url":"api/metadata.html","title":"元数据","keywords":"","body":"元数据 "},"api/schemas.html":{"url":"api/schemas.html","title":"Schemas","keywords":"","body":"Schemas "},"api/formatsuffixes.html":{"url":"api/formatsuffixes.html","title":"Format suffixes","keywords":"","body":"Format suffixes "},"api/urls.html":{"url":"api/urls.html","title":"Returning URLs","keywords":"","body":"Returning URLs "},"api/exceptions.html":{"url":"api/exceptions.html","title":"异常处理","keywords":"","body":"异常处理 "},"api/statuscodes.html":{"url":"api/statuscodes.html","title":"状态码","keywords":"","body":"状态码 "},"api/testing.html":{"url":"api/testing.html","title":"测试","keywords":"","body":"测试 "},"api/settings.html":{"url":"api/settings.html","title":"Settings","keywords":"","body":"Settings "},"topics/docs.html":{"url":"topics/docs.html","title":"API文档生成","keywords":"","body":"API文档生成 "}}